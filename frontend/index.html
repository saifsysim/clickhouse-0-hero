<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ClickHouse Explorer ‚Äì Interactive Demo</title>
  <meta name="description"
    content="Interactive ClickHouse demo showcasing MergeTree engines, telemetry dashboards, structured logging, and cost/usage analytics." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
    rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <!-- ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ -->
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" />
        </svg>
      </div>
      <div>
        <div class="logo-title">ClickHouse</div>
        <div class="logo-sub">Explorer</div>
      </div>
    </div>

    <nav class="sidebar-nav">
      <div class="nav-section-label">Learn</div>
      <button class="nav-item guide-nav-item" data-tab="guide" onclick="switchTab('guide',this)" id="guide-nav-btn">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" stroke="currentColor" stroke-width="2"
            stroke-linejoin="round" />
          <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" stroke="currentColor" stroke-width="2"
            stroke-linejoin="round" />
        </svg>
        Learning Guide
      </button>
      <button class="nav-item mistakes-nav-item" data-tab="mistakes" onclick="switchTab('mistakes',this)"
        id="mistakes-nav-btn">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"
            stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
          <line x1="12" y1="9" x2="12" y2="13" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
          <line x1="12" y1="17" x2="12.01" y2="17" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
        13 Mistakes
      </button>

      <div class="nav-section-label">Overview</div>
      <button class="nav-item active" data-tab="home" onclick="switchTab('home',this)">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" stroke="currentColor" stroke-width="2" />
          <polyline points="9 22 9 12 15 12 15 22" stroke="currentColor" stroke-width="2" />
        </svg>
        Introduction
      </button>
      <button class="nav-item" data-tab="engines" onclick="switchTab('engines',this)">
        <svg viewBox="0 0 24 24" fill="none">
          <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="2" />
          <path
            d="M19.07 4.93l-1.41 1.41M4.93 4.93l1.41 1.41M4.93 19.07l1.41-1.41M19.07 19.07l-1.41-1.41M12 2v2m0 18v-2m10-8h-2M4 12H2"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
        DB Engines
      </button>

      <div class="nav-section-label">Use Cases</div>
      <button class="nav-item" data-tab="telemetry" onclick="switchTab('telemetry',this)">
        <svg viewBox="0 0 24 24" fill="none">
          <polyline points="22 12 18 12 15 21 9 3 6 12 2 12" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" />
        </svg>
        Telemetry
      </button>
      <button class="nav-item" data-tab="logging" onclick="switchTab('logging',this)">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" stroke="currentColor" stroke-width="2" />
          <polyline points="14 2 14 8 20 8" stroke="currentColor" stroke-width="2" />
          <line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2" />
          <line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2" />
          <polyline points="10 9 9 9 8 9" stroke="currentColor" stroke-width="2" />
        </svg>
        Structured Logging
      </button>
      <button class="nav-item" data-tab="costs" onclick="switchTab('costs',this)">
        <svg viewBox="0 0 24 24" fill="none">
          <line x1="12" y1="1" x2="12" y2="23" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
          <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" />
        </svg>
        Cost & Usage
      </button>

      <div class="nav-section-label">Playground</div>
      <button class="nav-item" data-tab="cluster" onclick="switchTab('cluster',this)">
        <svg viewBox="0 0 24 24" fill="none">
          <circle cx="12" cy="5" r="3" stroke="currentColor" stroke-width="2" />
          <circle cx="5" cy="19" r="3" stroke="currentColor" stroke-width="2" />
          <circle cx="19" cy="19" r="3" stroke="currentColor" stroke-width="2" />
          <path d="M12 8v3m0 0-5 5m5-5 5 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
        Cluster & Replication
      </button>
      <button class="nav-item" data-tab="query" onclick="switchTab('query',this)">
        <svg viewBox="0 0 24 24" fill="none">
          <polyline points="4 17 10 11 4 5" stroke="currentColor" stroke-width="2" stroke-linecap="round"
            stroke-linejoin="round" />
          <line x1="12" y1="19" x2="20" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
        SQL Playground
      </button>
    </nav>

    <div class="sidebar-footer">
      <div class="connection-badge" id="connectionBadge">
        <span class="badge-dot"></span>
        <span id="connectionText">Connecting‚Ä¶</span>
      </div>
    </div>
  </aside>

  <!-- ‚îÄ‚îÄ Main ‚îÄ‚îÄ -->
  <main class="main-content">
    <!-- ‚îÄ‚îÄ‚îÄ HOME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel active" id="tab-home">
      <div class="page-header">
        <h1>Welcome to ClickHouse Explorer</h1>
        <p class="page-subtitle">An interactive, hands-on introduction to ClickHouse ‚Äî the blazing-fast columnar OLAP
          database. Explore real data across three production use cases.</p>
      </div>

      <div class="intro-grid">
        <div class="intro-card glass">
          <div class="intro-icon" style="background:linear-gradient(135deg,#f59e0b,#d97706)">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round" />
            </svg>
          </div>
          <h3>Blazing Fast</h3>
          <p>ClickHouse processes billions of rows per second using vectorized query execution and columnar storage.</p>
        </div>
        <div class="intro-card glass">
          <div class="intro-icon" style="background:linear-gradient(135deg,#6366f1,#4f46e5)">
            <svg viewBox="0 0 24 24" fill="none">
              <path
                d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"
                stroke="currentColor" stroke-width="2" />
            </svg>
          </div>
          <h3>Rich Engine Family</h3>
          <p>Six specialized table engines ‚Äî each optimised for different workloads: time-series, aggregation,
            deduplication, and more.</p>
        </div>
        <div class="intro-card glass">
          <div class="intro-icon" style="background:linear-gradient(135deg,#10b981,#059669)">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round" />
              <polyline points="22 4 12 14.01 9 11.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round" />
            </svg>
          </div>
          <h3>Production Ready</h3>
          <p>Battle-tested by Cloudflare, Uber, and hundreds of enterprises processing petabytes of data.</p>
        </div>
      </div>

      <div class="section-title">What You'll Learn</div>
      <div class="learn-grid">
        <div class="learn-item" onclick="switchTab('engines', document.querySelector('[data-tab=engines]'))">
          <div class="learn-num">01</div>
          <div>
            <strong>Database Engines</strong>
            <p>MergeTree, SummingMergeTree, AggregatingMergeTree, ReplacingMergeTree, CollapsingMergeTree</p>
          </div>
        </div>
        <div class="learn-item" onclick="switchTab('telemetry', document.querySelector('[data-tab=telemetry]'))">
          <div class="learn-num">02</div>
          <div>
            <strong>Telemetry Pipeline</strong>
            <p>High-throughput event ingestion, real-time dashboards, funnels, and user analytics</p>
          </div>
        </div>
        <div class="learn-item" onclick="switchTab('logging', document.querySelector('[data-tab=logging]'))">
          <div class="learn-num">03</div>
          <div>
            <strong>Structured Logging</strong>
            <p>Indexed log storage with TTL, full-text search, error rate tracking, and trace correlation</p>
          </div>
        </div>
        <div class="learn-item" onclick="switchTab('costs', document.querySelector('[data-tab=costs]'))">
          <div class="learn-num">04</div>
          <div>
            <strong>Cost & Usage Analytics</strong>
            <p>API spend tracking, per-team budgets, anomaly alerts, and cost-per-call analysis</p>
          </div>
        </div>
      </div>

      <div class="section-title">ClickHouse Architecture at a Glance</div>
      <div class="arch-diagram glass">
        <div class="arch-column">
          <div class="arch-label">Ingestion</div>
          <div class="arch-item">HTTP / TCP Client</div>
          <div class="arch-item">Kafka / S3</div>
          <div class="arch-item">Bulk INSERT</div>
        </div>
        <div class="arch-arrow">‚Üí</div>
        <div class="arch-column">
          <div class="arch-label">Storage</div>
          <div class="arch-item">Columnar Parquet</div>
          <div class="arch-item">Parts & Merges</div>
          <div class="arch-item">Sparse Indexes</div>
        </div>
        <div class="arch-arrow">‚Üí</div>
        <div class="arch-column">
          <div class="arch-label">Engines</div>
          <div class="arch-item arch-highlight">MergeTree</div>
          <div class="arch-item arch-highlight">Aggregating</div>
          <div class="arch-item arch-highlight">Replacing</div>
        </div>
        <div class="arch-arrow">‚Üí</div>
        <div class="arch-column">
          <div class="arch-label">Query</div>
          <div class="arch-item">Vectorized Exec</div>
          <div class="arch-item">Parallel Scans</div>
          <div class="arch-item">Materialized Views</div>
        </div>
      </div>
    </section>

    <!-- ‚îÄ‚îÄ‚îÄ ENGINES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-engines">
      <div class="page-header">
        <h1>ClickHouse Table Engines</h1>
        <p class="page-subtitle">Every table in ClickHouse uses an <em>engine</em> that defines how data is stored,
          merged, and queried. Choose the right engine for your workload.</p>
      </div>

      <div class="engines-grid">

        <div class="engine-card glass">
          <div class="engine-badge" style="background:linear-gradient(135deg,#f59e0b,#d97706)">MergeTree</div>
          <h3>MergeTree</h3>
          <p class="engine-desc">The <strong>foundation</strong> of all ClickHouse engines. Data is written in parts,
            then merged in the background. Supports <code>ORDER BY</code>, <code>PARTITION BY</code>, sparse primary
            indexes, and <code>TTL</code>.</p>
          <div class="code-block">
            -- Used for: telemetry_events, app_logs
            CREATE TABLE events (
            timestamp DateTime,
            service LowCardinality(String),
            user_id String
            )
            ENGINE = MergeTree()
            PARTITION BY toYYYYMM(timestamp)
            ORDER BY (service, timestamp)
            TTL timestamp + INTERVAL 90 DAY;</div>
          <div class="use-cases">
            <span class="tag">üì° Telemetry</span>
            <span class="tag">üìã Logs</span>
            <span class="tag">üìà Time-series</span>
          </div>
          <button class="btn btn-sm" onclick="runEngineDemo('mergetree-demo')">‚ñ∂ Run Live Demo</button>
          <div class="engine-result" id="result-mergetree-demo"></div>
        </div>

        <div class="engine-card glass">
          <div class="engine-badge" style="background:linear-gradient(135deg,#10b981,#059669)">SummingMergeTree</div>
          <h3>SummingMergeTree</h3>
          <p class="engine-desc">Automatically <strong>sums numeric columns</strong> during merges. Perfect for counters
            and accumulators ‚Äî no aggregation needed at query time.</p>
          <div class="code-block">
            -- Used for: cost_usage
            CREATE TABLE cost_usage (
            timestamp DateTime,
            service LowCardinality(String),
            team LowCardinality(String),
            cost_usd Float64,
            api_calls UInt32
            )
            ENGINE = SummingMergeTree(
            (cost_usd, api_calls) -- columns to sum
            )
            ORDER BY (team, service, timestamp);</div>
          <div class="use-cases">
            <span class="tag">üí∞ Cost Tracking</span>
            <span class="tag">üìä Budget Rollup</span>
          </div>
          <button class="btn btn-sm" onclick="runEngineDemo('summing-demo')">‚ñ∂ Run Live Demo</button>
          <div class="engine-result" id="result-summing-demo"></div>
        </div>

        <div class="engine-card glass">
          <div class="engine-badge" style="background:linear-gradient(135deg,#6366f1,#4f46e5)">AggregatingMergeTree
          </div>
          <h3>AggregatingMergeTree</h3>
          <p class="engine-desc">Stores <strong>partial aggregate states</strong> (e.g. HyperLogLog for
            <code>uniq</code>). Used with <em>Materialized Views</em> for blazing-fast pre-computed rollups.
          </p>
          <div class="code-block">
            -- Backing table for the hourly rollup MV
            CREATE TABLE telemetry_hourly_agg (
            hour DateTime,
            service LowCardinality(String),
            event_count AggregateFunction(count),
            unique_users AggregateFunction(uniq, String)
            )
            ENGINE = AggregatingMergeTree()
            ORDER BY (service, hour);

            -- Materialized View feeds it automatically
            CREATE MATERIALIZED VIEW mv_hourly
            TO telemetry_hourly_agg AS
            SELECT toStartOfHour(ts) AS hour, service,
            countState() AS event_count,
            uniqState(user_id) AS unique_users
            FROM events GROUP BY hour, service;</div>
          <div class="use-cases">
            <span class="tag">üìâ Rollups</span>
            <span class="tag">üî≠ Pre-aggregation</span>
          </div>
          <button class="btn btn-sm" onclick="runEngineDemo('aggregating-demo')">‚ñ∂ Run Live Demo</button>
          <div class="engine-result" id="result-aggregating-demo"></div>
        </div>

        <div class="engine-card glass">
          <div class="engine-badge" style="background:linear-gradient(135deg,#ec4899,#db2777)">ReplacingMergeTree</div>
          <h3>ReplacingMergeTree</h3>
          <p class="engine-desc">Keeps only the <strong>latest version</strong> of each row with the same
            <code>ORDER BY</code> key. Great for upsert-style workloads. Deduplication happens asynchronously on merge.
          </p>
          <div class="code-block">
            -- Used for: error_summary
            CREATE TABLE error_summary (
            date Date,
            service LowCardinality(String),
            error_msg String,
            count UInt32,
            version UInt64 -- higher wins
            )
            ENGINE = ReplacingMergeTree(version)
            ORDER BY (date, service, error_msg);

            -- "Upsert" by re-inserting with new version:
            INSERT INTO error_summary VALUES
            (today(), 'api', 'timeout', 42, now64());</div>
          <div class="use-cases">
            <span class="tag">‚ö†Ô∏è Deduplication</span>
            <span class="tag">üîÑ Upserts</span>
          </div>
          <button class="btn btn-sm" onclick="runEngineDemo('replicated-demo')">‚ñ∂ Run Live Demo</button>
          <div class="engine-result" id="result-replicated-demo"></div>
        </div>

        <div class="engine-card glass">
          <div class="engine-badge" style="background:linear-gradient(135deg,#f97316,#ea580c)">CollapsingMergeTree</div>
          <h3>CollapsingMergeTree</h3>
          <p class="engine-desc">Uses a <strong>sign column</strong> (+1/-1) to cancel previous rows. Allows efficient
            in-place corrections without mutations ‚Äî perfect for billing adjustments.</p>
          <div class="code-block">
            -- Used for: budget_limits
            CREATE TABLE budget_limits (
            date Date,
            team LowCardinality(String),
            budget_usd Float64,
            sign Int8 -- +1 insert, -1 cancel
            )
            ENGINE = CollapsingMergeTree(sign)
            ORDER BY (date, team);

            -- Correct a budget: cancel then re-insert
            INSERT INTO budget_limits VALUES
            ('2024-01-01', 'core-platform', 5000, -1),
            ('2024-01-01', 'core-platform', 7500, +1);</div>
          <div class="use-cases">
            <span class="tag">üîÅ Corrections</span>
            <span class="tag">üí≥ Billing</span>
          </div>
          <button class="btn btn-sm" onclick="runEngineDemo('aggregating-demo')">‚ñ∂ View Budget Data</button>
          <div class="engine-result" id="result-collapsing-demo"></div>
        </div>

        <div class="engine-card glass">
          <div class="engine-badge" style="background:linear-gradient(135deg,#14b8a6,#0d9488)">ReplicatedMergeTree</div>
          <h3>ReplicatedMergeTree</h3>
          <p class="engine-desc">All MergeTree variants have a <strong>Replicated</strong> counterpart. Data is
            synchronised across shards via <em>ZooKeeper / ClickHouse Keeper</em> for high availability.</p>
          <div class="code-block">
            -- Production HA setup on 2+ nodes:
            CREATE TABLE events ON CLUSTER my_cluster (
            timestamp DateTime,
            service String
            )
            ENGINE = ReplicatedMergeTree(
            '/clickhouse/tables/{shard}/events',
            '{replica}' -- auto-substituted
            )
            ORDER BY (service, timestamp);
            -- Reads+writes auto-fan-out to all replicas</div>
          <div class="use-cases">
            <span class="tag">üîí High Availability</span>
            <span class="tag">üåç Sharding</span>
          </div>
          <button class="btn btn-sm" onclick="runEngineDemo('replicated-demo')">‚ñ∂ View Log Stats</button>
          <div class="engine-result" id="result-replicated2-demo"></div>
        </div>

      </div>
    </section>

    <!-- ‚îÄ‚îÄ‚îÄ TELEMETRY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-telemetry">
      <div class="page-header">
        <h1>Telemetry Dashboard</h1>
        <p class="page-subtitle">Real-time event analytics powered by ClickHouse's <strong>MergeTree</strong> engine and
          <strong>Materialized Views</strong>. Simulating 30k+ events from 7 microservices.
        </p>
      </div>

      <div class="kpi-row" id="telemetryKpis">
        <div class="kpi-card glass">
          <div class="kpi-value" id="kpi-total-events">‚Äî</div>
          <div class="kpi-label">Total Events</div>
        </div>
        <div class="kpi-card glass">
          <div class="kpi-value" id="kpi-unique-users">‚Äî</div>
          <div class="kpi-label">Unique Users</div>
        </div>
        <div class="kpi-card glass">
          <div class="kpi-value" id="kpi-services">‚Äî</div>
          <div class="kpi-label">Active Services</div>
        </div>
        <div class="kpi-card glass">
          <div class="kpi-value" id="kpi-p95">‚Äî</div>
          <div class="kpi-label">P95 Duration (ms)</div>
        </div>
      </div>

      <div class="charts-row">
        <div class="chart-card glass">
          <div class="chart-header">
            <h3>Events Over Time (24h)</h3>
            <div class="chart-note">MergeTree ORDER BY (service, timestamp)</div>
          </div>
          <canvas id="telemetryTimelineChart" height="240"></canvas>
        </div>
        <div class="chart-card glass" style="flex:0 0 340px">
          <div class="chart-header">
            <h3>Event Type Breakdown</h3>
            <div class="chart-note">Queried in &lt; 50ms on 30k rows</div>
          </div>
          <canvas id="telemetryFunnelChart" height="240"></canvas>
        </div>
      </div>

      <div class="chart-card glass">
        <div class="chart-header">
          <h3>Top Services by Event Volume</h3>
          <div class="chart-note">uniq(user_id) uses HyperLogLog for O(1) cardinality</div>
        </div>
        <canvas id="servicesChart" height="160"></canvas>
      </div>

      <div class="section-title" style="margin-top:2rem">Inject a Live Event</div>
      <div class="inject-panel glass">
        <div class="form-row">
          <div class="form-group">
            <label>Service</label>
            <select id="inject-service">
              <option>frontend</option>
              <option>api-gateway</option>
              <option>auth-service</option>
              <option>payment-service</option>
              <option>recommendation-engine</option>
              <option>data-pipeline</option>
            </select>
          </div>
          <div class="form-group">
            <label>Event Type</label>
            <select id="inject-event">
              <option>page_view</option>
              <option>click</option>
              <option>search</option>
              <option>purchase</option>
              <option>signup</option>
              <option>api_call</option>
            </select>
          </div>
          <div class="form-group">
            <label>User ID</label>
            <input id="inject-user" type="text" value="user-1234" />
          </div>
          <button class="btn btn-primary" onclick="injectEvent()">‚ö° INSERT INTO ClickHouse</button>
        </div>
        <div id="inject-result" class="inject-result"></div>
      </div>
    </section>

    <!-- ‚îÄ‚îÄ‚îÄ LOGGING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-logging">
      <div class="page-header">
        <h1>Structured Logging</h1>
        <p class="page-subtitle">ClickHouse as your log store ‚Äî with <strong>TTL auto-expiry</strong>, full-text search,
          and sub-second queries across millions of log lines.</p>
      </div>

      <div class="kpi-row">
        <div class="kpi-card glass kpi-debug">
          <div class="kpi-value" id="log-debug">‚Äî</div>
          <div class="kpi-label">DEBUG</div>
        </div>
        <div class="kpi-card glass kpi-info">
          <div class="kpi-value" id="log-info">‚Äî</div>
          <div class="kpi-label">INFO</div>
        </div>
        <div class="kpi-card glass kpi-warn">
          <div class="kpi-value" id="log-warn">‚Äî</div>
          <div class="kpi-label">WARN</div>
        </div>
        <div class="kpi-card glass kpi-error">
          <div class="kpi-value" id="log-error">‚Äî</div>
          <div class="kpi-label">ERROR</div>
        </div>
      </div>

      <div class="charts-row">
        <div class="chart-card glass">
          <div class="chart-header">
            <h3>Error & Warning Rate (24h)</h3>
            <div class="chart-note">toStartOfHour() partitioning enables fast range scans</div>
          </div>
          <canvas id="logErrorRateChart" height="200"></canvas>
        </div>
        <div class="chart-card glass" style="flex: 0 0 360px">
          <div class="chart-header">
            <h3>Top Errors (24h)</h3>
          </div>
          <div id="topErrorsList" class="top-errors-list"></div>
        </div>
      </div>

      <div class="logs-toolbar glass">
        <div class="form-group">
          <label>Level</label>
          <select id="log-level-filter" onchange="loadLogs()">
            <option value="all">All Levels</option>
            <option value="DEBUG">DEBUG</option>
            <option value="INFO">INFO</option>
            <option value="WARN">WARN</option>
            <option value="ERROR">ERROR</option>
          </select>
        </div>
        <div class="form-group">
          <label>Service</label>
          <select id="log-service-filter" onchange="loadLogs()">
            <option value="all">All Services</option>
            <option>frontend</option>
            <option>api-gateway</option>
            <option>auth-service</option>
            <option>payment-service</option>
            <option>recommendation-engine</option>
            <option>data-pipeline</option>
            <option>ml-inference</option>
          </select>
        </div>
        <div class="form-group" style="flex:1">
          <label>Search</label>
          <input id="log-search" type="text" placeholder="Search messages‚Ä¶" oninput="debounceLoadLogs()" />
        </div>
        <button class="btn btn-primary" onclick="loadLogs()">üîç Query</button>
      </div>

      <div class="log-table-wrap glass">
        <table class="log-table">
          <thead>
            <tr>
              <th>Time</th>
              <th>Level</th>
              <th>Service</th>
              <th>Host</th>
              <th>Duration</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody id="logTableBody">
            <tr>
              <td colspan="6" class="loading-row">Loading‚Ä¶</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- ‚îÄ‚îÄ‚îÄ COSTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-costs">
      <div class="page-header">
        <h1>Cost & Usage Analytics</h1>
        <p class="page-subtitle">Track API spend, token consumption, and per-team budgets. Powered by
          <strong>SummingMergeTree</strong> ‚Äî totals are maintained automatically during merges.
        </p>
      </div>

      <div class="kpi-row" id="costKpis">
        <div class="kpi-card glass">
          <div class="kpi-value" id="cost-total">‚Äî</div>
          <div class="kpi-label">Total Spend (30d)</div>
        </div>
        <div class="kpi-card glass">
          <div class="kpi-value" id="cost-tokens">‚Äî</div>
          <div class="kpi-label">Total Tokens</div>
        </div>
        <div class="kpi-card glass">
          <div class="kpi-value" id="cost-calls">‚Äî</div>
          <div class="kpi-label">API Calls</div>
        </div>
        <div class="kpi-card glass">
          <div class="kpi-value" id="cost-avg">‚Äî</div>
          <div class="kpi-label">Avg Cost / 1k calls</div>
        </div>
      </div>

      <div id="cost-alerts" class="alerts-row"></div>

      <div class="charts-row">
        <div class="chart-card glass">
          <div class="chart-header">
            <h3>Daily Spend (30 days)</h3>
            <div class="chart-note">SummingMergeTree auto-sums cost_usd during background merges</div>
          </div>
          <canvas id="dailyCostChart" height="220"></canvas>
        </div>
        <div class="chart-card glass" style="flex: 0 0 340px">
          <div class="chart-header">
            <h3>Spend by Team</h3>
          </div>
          <canvas id="teamCostChart" height="220"></canvas>
        </div>
      </div>

      <div class="chart-card glass">
        <div class="chart-header">
          <h3>Cost per Service (30d)</h3>
          <div class="chart-note">GROUP BY service with avg(cost_usd / api_calls)</div>
        </div>
        <div id="servicesCostTable" class="services-cost-table"></div>
      </div>
    </section>

    <!-- ‚îÄ‚îÄ‚îÄ CLUSTER & REPLICATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-cluster">
      <div class="page-header">
        <h1>Sharding &amp; Replication</h1>
        <p class="page-subtitle">Two fundamental ClickHouse cluster concepts ‚Äî <strong>Sharding</strong> splits data
          horizontally across nodes for scale, while <strong>Replication</strong> duplicates data across nodes for high
          availability. This live demo runs a real 2-node cluster.</p>
      </div>

      <!-- Concept Cards -->
      <div class="intro-grid" style="grid-template-columns:repeat(2,1fr);margin-bottom:20px">
        <div class="intro-card glass">
          <div class="intro-icon" style="background:linear-gradient(135deg,#f59e0b,#d97706)">
            <svg viewBox="0 0 24 24" fill="none">
              <rect x="2" y="3" width="9" height="18" rx="2" stroke="currentColor" stroke-width="2" />
              <rect x="13" y="3" width="9" height="18" rx="2" stroke="currentColor" stroke-width="2" />
            </svg>
          </div>
          <h3>Sharding ‚Äî Scale Out</h3>
          <p style="color:var(--text2);font-size:13px;margin-bottom:10px">Each <strong>shard</strong> owns a distinct
            subset of the data. A <code>Distributed</code> table fans writes out (using a sharding key hash) and merges
            reads from all shards transparently.</p>
          <div class="code-block" style="font-size:11px">-- Sharding key assigns each row to a shard
            ENGINE = Distributed(
            demo_cluster, -- cluster name
            cluster_demo, -- database
            events_local, -- local table on each shard
            murmurHash3_32(user_id)-- sharding key
            );
            -- user-42 always goes to shard 1
            -- user-99 always goes to shard 2</div>
          <div class="use-cases">
            <span class="tag">üìà Horizontal Scale</span>
            <span class="tag">‚ö° Parallel Reads</span>
            <span class="tag">üîÄ Hash Routing</span>
          </div>
        </div>

        <div class="intro-card glass">
          <div class="intro-icon" style="background:linear-gradient(135deg,#6366f1,#4f46e5)">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor"
                stroke-width="2" />
            </svg>
          </div>
          <h3>Replication ‚Äî High Availability</h3>
          <p style="color:var(--text2);font-size:13px;margin-bottom:10px">Each <strong>replica</strong> holds the same
            data. <strong>ClickHouse Keeper</strong> (ZooKeeper-compatible) coordinates which replica is primary and
            syncs inserts automatically.</p>
          <div class="code-block" style="font-size:11px">-- SAME ZK path on both replicas
            -- different {replica} macro per node
            ENGINE = ReplicatedMergeTree(
            '/clickhouse/tables/ha/events', -- shared ZK path
            '{replica}' -- replica-1 on node1
            -- replica-2 on node2
            );
            -- Write to node1 ‚Üí auto-synced to node2!</div>
          <div class="use-cases">
            <span class="tag">üîí High Availability</span>
            <span class="tag">üîÑ Auto-Sync</span>
            <span class="tag">üíæ Keeper Coord.</span>
          </div>
        </div>
      </div>

      <!-- Architecture Diagram -->
      <div class="section-title">Live Cluster Architecture</div>
      <div class="cluster-arch glass">
        <div class="ca-box ca-client">
          <div class="ca-icon">üñ•</div>
          <div class="ca-title">Your App</div>
          <div class="ca-sub">INSERT / SELECT</div>
        </div>
        <div class="ca-arrow-col">
          <div class="ca-arrow-line">‚Üì INSERT (fan-out)</div>
          <div class="ca-arrow-line" style="color:var(--green)">‚Üë SELECT (merge)</div>
        </div>
        <div class="ca-box ca-dist">
          <div class="ca-icon">‚ö°</div>
          <div class="ca-title">Distributed Table</div>
          <div class="ca-sub">murmurHash3_32(user_id)</div>
          <div class="ca-sub" style="color:var(--ch-yellow)">ENGINE = Distributed(demo_cluster‚Ä¶)</div>
        </div>
        <div class="ca-arrow-col">
          <div class="ca-arrow-line" style="color:var(--ch-yellow)">‚Üí shard 01</div>
          <div class="ca-arrow-line" style="color:var(--accent2)">‚Üí shard 02</div>
        </div>
        <div class="ca-shards-col">
          <div class="ca-box ca-shard" id="nodeStatusBox1">
            <div class="ca-icon">üü°</div>
            <div class="ca-title">clickhouse-node1</div>
            <div class="ca-sub">Shard 01 ¬∑ Replica 1</div>
            <div class="ca-sub">Port 8124</div>
            <div class="ca-sub" id="ca-node1-status">Checking‚Ä¶</div>
          </div>
          <div class="ca-keeper">
            <div style="font-size:11px;color:var(--text3)">‚Üï ZK sync</div>
            <div class="ca-box ca-keeper-box">
              <div class="ca-icon">üóù</div>
              <div class="ca-title">CH Keeper</div>
              <div class="ca-sub">Port 9181</div>
            </div>
          </div>
          <div class="ca-box ca-shard" id="nodeStatusBox2">
            <div class="ca-icon">üü°</div>
            <div class="ca-title">clickhouse-node2</div>
            <div class="ca-sub">Shard 02 ¬∑ Replica 2</div>
            <div class="ca-sub">Port 8125</div>
            <div class="ca-sub" id="ca-node2-status">Checking‚Ä¶</div>
          </div>
        </div>
      </div>

      <!-- Cluster Topology Table -->
      <div class="section-title" style="margin-top:24px">Live Topology (system.clusters)</div>
      <div class="glass" style="padding:0;overflow:hidden;border-radius:var(--radius);margin-bottom:20px">
        <table class="log-table" id="clusterTopologyTable">
          <thead>
            <tr>
              <th>Cluster</th>
              <th>Shard</th>
              <th>Replica</th>
              <th>Host</th>
              <th>Port</th>
              <th>Is Local</th>
            </tr>
          </thead>
          <tbody id="topoTableBody">
            <tr>
              <td colspan="6" class="loading-row">Loading‚Ä¶</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Two demo sections -->
      <div class="charts-row" style="gap:20px;align-items:flex-start">

        <!-- SHARDING DEMO -->
        <div class="glass" style="flex:1;padding:22px;border-radius:var(--radius)">
          <h3 style="margin-bottom:6px">üîÄ Sharding Demo</h3>
          <p style="font-size:12.5px;color:var(--text2);margin-bottom:16px">8,000 rows were inserted via the
            <code>Distributed</code> table. ClickHouse routed each row to a shard using
            <code>murmurHash3_32(user_id)</code>.
          </p>
          <canvas id="shardDistChart" height="160"></canvas>
          <div class="section-title" style="margin-top:16px">Insert a test row ‚Üí</div>
          <div class="form-row" style="flex-wrap:wrap">
            <div class="form-group">
              <label>User ID</label>
              <input id="shard-user-id" type="text" value="user-42" style="width:140px" />
            </div>
            <div class="form-group">
              <label>Service</label>
              <select id="shard-service">
                <option>frontend</option>
                <option>api-gateway</option>
                <option>auth-service</option>
                <option>payment-service</option>
                <option>ml-inference</option>
              </select>
            </div>
            <button class="btn btn-primary btn-sm" onclick="insertAndRoute()">‚ö° INSERT &amp; Route</button>
          </div>
          <div id="shard-route-result" class="shard-route-result"></div>

          <!-- Cross-shard query button -->
          <div class="section-title" style="margin-top:14px">Cross-shard query ‚Üí</div>
          <button class="btn btn-sm" onclick="runDistributedQuery()">üåê SELECT from Distributed table</button>
          <div class="engine-result" id="distributed-result" style="margin-top:10px"></div>
        </div>

        <!-- REPLICATION DEMO -->
        <div class="glass" style="flex:1;padding:22px;border-radius:var(--radius)">
          <h3 style="margin-bottom:6px">üîÑ Replication Demo</h3>
          <p style="font-size:12.5px;color:var(--text2);margin-bottom:16px">Both nodes share the table
            <code>events_replicated</code> under <em>the same ZK path</em>. Write to node1, and node2 gets it
            automatically via ClickHouse Keeper.
          </p>

          <!-- Row count per replica -->
          <div id="repl-row-counts" class="repl-counts-row">Loading‚Ä¶</div>

          <!-- Live replication button -->
          <div class="section-title" style="margin-top:16px">Prove replication live ‚Üí</div>
          <button class="btn btn-primary" id="replBtn" onclick="runReplicationDemo()">
            ‚úçÔ∏è Write to node1 ‚Üí Verify on node2
          </button>
          <div id="repl-result" class="repl-result"></div>

          <!-- ZK path explanation -->
          <div class="section-title" style="margin-top:16px">How Keeper coordinates this</div>
          <div class="code-block" style="font-size:11px">-- ZooKeeper/Keeper path layout:
            /clickhouse/tables/ha/events_replicated/
            replicas/
            replica-1/ ‚Üê node1 registers here
            log_pointer
            is_active
            host: clickhouse-node1
            replica-2/ ‚Üê node2 registers here
            log_pointer
            is_active
            host: clickhouse-node2
            log/ ‚Üê shared INSERT log
            log-0000001 (INSERT from node1)
            log-0000002 ‚Üí node2 pulls &amp; applies</div>

          <!-- system.replicas -->
          <div class="section-title" style="margin-top:12px">system.replicas ‚Üí</div>
          <button class="btn btn-sm" onclick="loadReplStatus()">üîç Check Replication Status</button>
          <div class="engine-result" id="repl-status-result" style="margin-top:10px"></div>
        </div>
      </div>

      <!-- SQL Reference -->
      <div class="section-title" style="margin-top:24px">Cluster SQL Reference</div>
      <div class="engines-grid" style="grid-template-columns:repeat(2,1fr);gap:14px">
        <div class="engine-card glass" style="padding:18px">
          <div class="engine-badge" style="background:linear-gradient(135deg,#f59e0b,#d97706)">ON CLUSTER</div>
          <div class="code-block" style="font-size:11px;margin-top:8px">-- Run DDL on ALL nodes at once:
            CREATE TABLE telemetry ON CLUSTER demo_cluster
            (
            ts DateTime,
            service String,
            user_id String
            )
            ENGINE = ReplicatedMergeTree(
            '/clickhouse/tables/{shard}/telemetry',
            '{replica}'
            )
            ORDER BY (service, ts);

            -- Then create the Distributed view:
            CREATE TABLE telemetry_all ON CLUSTER demo_cluster
            AS telemetry
            ENGINE = Distributed(
            demo_cluster, currentDatabase(),
            telemetry, rand()
            );</div>
        </div>
        <div class="engine-card glass" style="padding:18px">
          <div class="engine-badge" style="background:linear-gradient(135deg,#6366f1,#4f46e5)">Monitoring</div>
          <div class="code-block" style="font-size:11px;margin-top:8px">-- Check cluster topology:
            SELECT cluster, shard_num, host_name
            FROM system.clusters
            ORDER BY cluster, shard_num;

            -- Monitor replica lag:
            SELECT table, replica_name,
            queue_size,
            inserts_in_queue,
            last_queue_update
            FROM system.replicas;

            -- Replication queue details:
            SELECT database, table, type,
            num_tries, last_exception
            FROM system.replication_queue
            WHERE num_tries > 0
            ORDER BY create_time DESC;</div>
        </div>
      </div>

    </section>

    <!-- ‚îÄ‚îÄ‚îÄ QUERY PLAYGROUND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-query">
      <div class="page-header">
        <h1>SQL Playground</h1>
        <p class="page-subtitle">Run any ClickHouse SQL query against the live demo database. Explore all the tables
          seeded with realistic data.</p>
      </div>

      <div class="playground-layout">
        <div class="playground-sidebar">
          <div class="section-title">Quick Queries</div>
          <div class="quick-queries">
            <button class="quick-query-btn" onclick="setQuery(QUERIES.eventsByHour)">üìä Events by Hour</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.topUsers)">üë§ Top Users</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.errorRate)">üö® Error Rate</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.costByService)">üí∞ Cost by Service</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.p95Latency)">‚è± P95 Latency</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.uniqueUsers)">üî¢ HLL Unique Users</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.systemTables)">üóÑ System Tables</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.budgetCollapsing)">üìâ Budget Collapse</button>
            <button class="quick-query-btn" onclick="setQuery(QUERIES.ttlCheck)">‚åõ TTL Info</button>
          </div>

          <div class="section-title" style="margin-top:1.5rem">Tables in demo DB</div>
          <div id="playground-tables" class="table-list">Loading‚Ä¶</div>
        </div>

        <div class="playground-main">
          <div class="editor-wrap glass">
            <div class="editor-toolbar">
              <span class="editor-label">SQL</span>
              <button class="btn btn-primary btn-sm" onclick="runQuery()">‚ñ∂ Run Query</button>
              <button class="btn btn-sm" onclick="clearQuery()">‚úï Clear</button>
            </div>
            <textarea id="queryEditor" spellcheck="false"
              placeholder="SELECT * FROM telemetry_events LIMIT 10;"></textarea>
          </div>
          <div id="queryStatus" class="query-status"></div>
          <div class="results-wrap glass" id="queryResultsWrap" style="display:none">
            <div class="results-header">
              <span id="resultsCount"></span>
              <button class="btn btn-sm" onclick="copyResults()">üìã Copy JSON</button>
            </div>
            <div class="results-table-wrap">
              <table class="results-table" id="resultsTable"></table>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ‚îÄ‚îÄ‚îÄ LEARNING GUIDE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-guide">
      <div class="guide-layout">

        <!-- LEFT: module navigation -->
        <aside class="guide-sidebar glass">
          <div class="guide-sidebar-hd">
            <div class="guide-ttl">üìñ ClickHouse Guide</div>
            <div class="guide-sub">7 modules ¬∑ learn by doing</div>
            <div class="guide-prog-wrap">
              <div class="guide-prog-bar" id="guideProgBar" style="width:14.3%"></div>
            </div>
            <div class="guide-prog-lbl" id="guideProgLbl">Module 1 of 7</div>
          </div>
          <div class="guide-mod-list">
            <button class="guide-mod-btn active" onclick="showGuideModule(1,this)" id="gbtn-1">
              <span class="guide-mod-n">01</span>
              <div class="guide-mod-meta"><strong>Why ClickHouse?</strong><span>Columnar ¬∑ OLAP ¬∑ Architecture</span>
              </div>
            </button>
            <button class="guide-mod-btn" onclick="showGuideModule(2,this)" id="gbtn-2">
              <span class="guide-mod-n">02</span>
              <div class="guide-mod-meta"><strong>MergeTree: The Core</strong><span>Parts ¬∑ Merges ¬∑ ORDER BY</span>
              </div>
            </button>
            <button class="guide-mod-btn" onclick="showGuideModule(3,this)" id="gbtn-3">
              <span class="guide-mod-n">03</span>
              <div class="guide-mod-meta"><strong>Engine Variants</strong><span>Summing ¬∑ Aggregating ¬∑ Replacing ¬∑
                  Collapsing</span></div>
            </button>
            <button class="guide-mod-btn" onclick="showGuideModule(4,this)" id="gbtn-4">
              <span class="guide-mod-n">04</span>
              <div class="guide-mod-meta"><strong>Materialized Views</strong><span>MVs ¬∑ HyperLogLog ¬∑
                  Combinators</span></div>
            </button>
            <button class="guide-mod-btn" onclick="showGuideModule(5,this)" id="gbtn-5">
              <span class="guide-mod-n">05</span>
              <div class="guide-mod-meta"><strong>Logging &amp; TTL</strong><span>Auto-expiry ¬∑ LowCardinality ¬∑
                  Search</span></div>
            </button>
            <button class="guide-mod-btn" onclick="showGuideModule(6,this)" id="gbtn-6">
              <span class="guide-mod-n">06</span>
              <div class="guide-mod-meta"><strong>Cost &amp; Aggregations</strong><span>SummingMT ¬∑ Budget alerts ¬∑
                  Sign</span></div>
            </button>
            <button class="guide-mod-btn" onclick="showGuideModule(7,this)" id="gbtn-7">
              <span class="guide-mod-n">07</span>
              <div class="guide-mod-meta"><strong>Cluster &amp; Replication</strong><span>Sharding ¬∑ Distributed ¬∑
                  Keeper</span></div>
            </button>
          </div>
        </aside>

        <!-- RIGHT: lesson content -->
        <div class="guide-main">

          <!-- ‚îÄ‚îÄ MODULE 1: WHY CLICKHOUSE ‚îÄ‚îÄ -->
          <div class="guide-lesson" id="glesson-1">
            <div class="guide-lesson-hd">
              <div class="guide-lesson-num">Module 01</div>
              <h2 class="guide-lesson-title">Why ClickHouse?</h2>
              <p class="guide-lesson-desc">Understand what makes ClickHouse fundamentally different from traditional
                databases ‚Äî and when to reach for it.</p>
              <div class="guide-tags">
                <span class="tag">Columnar Storage</span>
                <span class="tag">OLAP vs OLTP</span>
                <span class="tag">Vectorized Execution</span>
              </div>
            </div>

            <div class="guide-callout guide-callout--key">
              <div class="guide-callout-label">üí° Core Idea</div>
              Traditional databases store rows together on disk. ClickHouse stores <strong>columns</strong> together.
              When you run <code>SELECT AVG(revenue)</code> on a 100-column table, ClickHouse reads only the
              <code>revenue</code> column ‚Äî not the other 99.
            </div>

            <h3 class="guide-h3">Row vs Columnar Storage</h3>
            <div class="guide-compare">
              <div class="guide-compare-side">
                <div class="guide-compare-label guide-compare-label--bad">Row Store (Postgres, MySQL)</div>
                <div class="guide-code-sm">Disk: [id|name|revenue|ts][id|name|revenue|ts]...

                  SELECT AVG(revenue) FROM events;
                  ‚Üí Must read ALL columns for every row
                  ‚Üí I/O: 100% of the table
                  ‚Üí Slow on analytics workloads</div>
              </div>
              <div class="guide-compare-side">
                <div class="guide-compare-label guide-compare-label--good">Columnar (ClickHouse)</div>
                <div class="guide-code-sm">Disk: [id][id]... [name][name]... [revenue][revenue]...

                  SELECT AVG(revenue) FROM events;
                  ‚Üí Reads ONLY the revenue column
                  ‚Üí I/O: 1% of the table
                  ‚Üí 100x faster on the same hardware</div>
              </div>
            </div>

            <h3 class="guide-h3">Vectorized Execution</h3>
            <p class="guide-p">Instead of processing one row at a time, ClickHouse processes a <strong>batch of 8,192
                values</strong> per CPU instruction using SIMD. Think of it as doing math on an entire column at once
              rather than looping through rows.</p>

            <div class="guide-callout guide-callout--info">
              <div class="guide-callout-label">üìä When to Use ClickHouse</div>
              <div class="guide-two-col">
                <div>
                  <div class="guide-check-item">‚úÖ Analytics queries (aggregations, GROUP BY)</div>
                  <div class="guide-check-item">‚úÖ Time-series data (logs, metrics, events)</div>
                  <div class="guide-check-item">‚úÖ Read-heavy workloads (dashboards, reports)</div>
                  <div class="guide-check-item">‚úÖ Billions of rows with fast scans</div>
                </div>
                <div>
                  <div class="guide-check-item guide-x">‚ùå High-frequency point updates (use Postgres)</div>
                  <div class="guide-check-item guide-x">‚ùå Complex transactions (use Postgres/MySQL)</div>
                  <div class="guide-check-item guide-x">‚ùå Small data under 1M rows (any DB works)</div>
                  <div class="guide-check-item guide-x">‚ùå JOIN-heavy OLTP workloads</div>
                </div>
              </div>
            </div>

            <h3 class="guide-h3">Compression ‚Äî The Secret Weapon</h3>
            <p class="guide-p">Columnar storage makes compression extremely effective. A column of
              <code>LowCardinality(String)</code> with values like <em>frontend, api-gateway, auth-service</em>
              compresses to nearly nothing ‚Äî because the same strings repeat millions of times.
            </p>
            <div class="guide-code-block">-- ClickHouse typically achieves 5-20x compression
              -- Example: 100GB of raw logs ‚Üí ~8GB on disk

              SELECT
              formatReadableSize(sum(bytes)) AS disk_size,
              formatReadableSize(sum(data_uncompressed_bytes)) AS raw_size,
              sum(data_uncompressed_bytes) / sum(bytes) AS ratio
              FROM system.parts
              WHERE database = 'demo' AND active;</div>

            <div class="guide-next-row">
              <button class="btn btn-primary" onclick="goToTab('home')">‚Üí Explore the Introduction tab</button>
              <button class="btn" onclick="showGuideModule(2, document.getElementById('gbtn-2'))">Next: MergeTree
                ‚Üí</button>
            </div>
          </div>

          <!-- ‚îÄ‚îÄ MODULE 2: MERGETREE ‚îÄ‚îÄ -->
          <div class="guide-lesson" id="glesson-2" style="display:none">
            <div class="guide-lesson-hd">
              <div class="guide-lesson-num">Module 02</div>
              <h2 class="guide-lesson-title">MergeTree: The Foundation</h2>
              <p class="guide-lesson-desc">Every ClickHouse engine you'll use is built on MergeTree. Understanding how
                it stores and merges data is the single most important ClickHouse concept.</p>
              <div class="guide-tags">
                <span class="tag">Parts</span><span class="tag">Merges</span><span class="tag">ORDER BY</span><span
                  class="tag">Sparse Index</span>
              </div>
            </div>

            <div class="guide-callout guide-callout--key">
              <div class="guide-callout-label">üí° Core Idea</div>
              ClickHouse never updates rows in-place. Every INSERT creates a new <strong>"part"</strong> (a folder of
              column files). Background <strong>merge jobs</strong> then combine small parts into larger, sorted ones.
              This is why ClickHouse is fast at INSERTs AND queries ‚Äî writes are always sequential appends.
            </div>

            <h3 class="guide-h3">The Parts Lifecycle</h3>
            <div class="guide-code-block">-- After 3 INSERTs you have 3 parts:
              /data/demo/telemetry_events/
              20240101_1_1_0/ ‚Üê part from INSERT #1 (sorted by ORDER BY)
              20240101_2_2_0/ ‚Üê part from INSERT #2
              20240101_3_3_0/ ‚Üê part from INSERT #3

              -- ClickHouse background thread merges them:
              20240101_1_3_1/ ‚Üê merged part (all 3 ‚Üí 1, fully sorted)
              (old parts deleted after merge completes)

              -- Each part contains one file per column:
              timestamp.bin ‚Üê compressed timestamp values
              service.bin ‚Üê compressed service values
              primary.idx ‚Üê sparse primary index (1 entry per 8192 rows)</div>

            <div class="guide-callout guide-callout--warn">
              <div class="guide-callout-label">‚ö†Ô∏è The Most Important Schema Decision</div>
              <code>ORDER BY</code> in ClickHouse is <strong>NOT</strong> a primary key ‚Äî it is the <strong>physical
                sort order on disk</strong>. This determines which queries run fast. A query that filters on your ORDER
              BY columns skips most of the data using the sparse index. A query that filters on other columns scans
              everything.
            </div>

            <h3 class="guide-h3">Choosing ORDER BY</h3>
            <div class="guide-compare">
              <div class="guide-compare-side">
                <div class="guide-compare-label guide-compare-label--bad">Wrong ORDER BY</div>
                <div class="guide-code-sm">ORDER BY (id) -- random IDs ‚Üí bad

                  -- "Show errors for api-gateway"
                  WHERE service = 'api-gateway'
                  ‚Üí Must scan ALL rows because
                  service is not the sort key
                  ‚Üí Full table scan every time</div>
              </div>
              <div class="guide-compare-side">
                <div class="guide-compare-label guide-compare-label--good">Right ORDER BY</div>
                <div class="guide-code-sm">ORDER BY (service, timestamp) -- ‚úì

                  -- "Show errors for api-gateway"
                  WHERE service = 'api-gateway'
                  ‚Üí Sparse index skips directly to
                  api-gateway rows
                  ‚Üí Reads only relevant granules</div>
              </div>
            </div>

            <h3 class="guide-h3">PARTITION BY ‚Äî Data Lifecycle</h3>
            <p class="guide-p"><code>PARTITION BY toYYYYMM(timestamp)</code> splits data into monthly folders. This lets
              you drop an entire month with <code>ALTER TABLE DROP PARTITION '202401'</code> ‚Äî instant, no scanning
              needed.</p>
            <div class="guide-code-block">CREATE TABLE app_logs (
              timestamp DateTime,
              service LowCardinality(String),
              level LowCardinality(String),
              message String
              )
              ENGINE = MergeTree()
              ORDER BY (service, level, timestamp) -- ‚Üê most-filtered columns first
              PARTITION BY toYYYYMM(timestamp) -- ‚Üê monthly partitions for lifecycle
              TTL timestamp + INTERVAL 90 DAY; -- ‚Üê auto-delete after 90 days</div>

            <div class="guide-next-row">
              <button class="btn btn-primary" onclick="goToTab('engines')">‚Üí Try the Engines tab</button>
              <button class="btn" onclick="showGuideModule(3, document.getElementById('gbtn-3'))">Next: Engine Variants
                ‚Üí</button>
            </div>
          </div>

          <!-- ‚îÄ‚îÄ MODULE 3: ENGINE VARIANTS ‚îÄ‚îÄ -->
          <div class="guide-lesson" id="glesson-3" style="display:none">
            <div class="guide-lesson-hd">
              <div class="guide-lesson-num">Module 03</div>
              <h2 class="guide-lesson-title">Engine Variants</h2>
              <p class="guide-lesson-desc">All ClickHouse engines inherit from MergeTree and differ only in what happens
                <em>during background merges</em>.
              </p>
              <div class="guide-tags">
                <span class="tag">SummingMergeTree</span><span class="tag">AggregatingMergeTree</span><span
                  class="tag">ReplacingMergeTree</span><span class="tag">CollapsingMergeTree</span>
              </div>
            </div>

            <div class="guide-callout guide-callout--key">
              <div class="guide-callout-label">üí° The Pattern</div>
              Every engine variant adds one behavior to the merge step: <em>"when two parts are being merged and two
                rows share the same ORDER BY key, do X."</em> The rest is identical to MergeTree.
            </div>

            <h3 class="guide-h3">SummingMergeTree ‚Äî Auto-sum counters</h3>
            <p class="guide-p">During merge, rows with the same ORDER BY key are collapsed and their numeric columns are
              <strong>summed</strong>. Perfect for counters and accumulators that you'll always query with GROUP BY
              anyway.
            </p>
            <div class="guide-code-block">-- cost_usage uses SummingMergeTree
              ENGINE = SummingMergeTree((cost_usd, api_calls, tokens_used))
              ORDER BY (team, service, toDate(timestamp))

              -- Three raw inserts:
              -- (platform, api-gateway, 0.05, 100)
              -- (platform, api-gateway, 0.03, 80)
              -- (platform, api-gateway, 0.08, 120)
              -- After merge: (platform, api-gateway, 0.16, 300) ‚Üê auto-summed!

              -- Query: always use sum() for correctness (parts may not all be merged yet)
              SELECT service, sum(cost_usd) AS total_cost
              FROM demo.cost_usage GROUP BY service ORDER BY total_cost DESC;</div>

            <h3 class="guide-h3">ReplacingMergeTree ‚Äî Upserts / Deduplication</h3>
            <p class="guide-p">During merge, rows with the same ORDER BY key are collapsed to the <strong>latest
                version</strong>. The version column (usually a timestamp or auto-increment) determines which row wins.
            </p>
            <div class="guide-code-block">-- error_summary uses ReplacingMergeTree
              ENGINE = ReplacingMergeTree(version) -- higher version wins
              ORDER BY (date, service, error_msg)

              -- "Upsert" pattern: re-insert with a higher version number
              INSERT INTO error_summary VALUES
              (today(), 'api-gateway', 'timeout', 42, toUnixTimestamp(now()));

              -- After merge, only the latest version survives
              -- Note: FINAL forces dedup at query time (slower) if not yet merged
              SELECT * FROM error_summary FINAL WHERE service = 'api-gateway';</div>

            <h3 class="guide-h3">CollapsingMergeTree ‚Äî Corrections with sign</h3>
            <p class="guide-p">Uses a <strong>sign column</strong> (+1 or -1). During merge, +1 rows cancel out -1 rows
              with the same ORDER BY key. This allows you to "delete" or "correct" a value by inserting a -1 row ‚Äî no
              mutations needed.</p>
            <div class="guide-code-block">-- budget_limits uses CollapsingMergeTree
              ENGINE = CollapsingMergeTree(sign)
              ORDER BY (date, team)

              -- Original budget:
              INSERT INTO budget_limits VALUES ('2024-01-01', 'platform', 5000.0, +1);

              -- Correct it (cancel old, insert new):
              INSERT INTO budget_limits VALUES
              ('2024-01-01', 'platform', 5000.0, -1), -- cancel old
              ('2024-01-01', 'platform', 7500.0, +1); -- new value

              -- Query the NET budget:
              SELECT team, sum(budget_usd * sign) AS effective_budget
              FROM budget_limits GROUP BY team HAVING effective_budget > 0;</div>

            <div class="guide-next-row">
              <button class="btn btn-primary" onclick="goToTab('engines')">‚Üí Run all engine demos</button>
              <button class="btn" onclick="showGuideModule(4, document.getElementById('gbtn-4'))">Next: Materialized
                Views ‚Üí</button>
            </div>
          </div>

          <!-- ‚îÄ‚îÄ MODULE 4: MATERIALIZED VIEWS ‚îÄ‚îÄ -->
          <div class="guide-lesson" id="glesson-4" style="display:none">
            <div class="guide-lesson-hd">
              <div class="guide-lesson-num">Module 04</div>
              <h2 class="guide-lesson-title">Materialized Views &amp; Approximations</h2>
              <p class="guide-lesson-desc">Pre-compute results at insert time so dashboards query in milliseconds ‚Äî plus
                learn how ClickHouse estimates <code>COUNT DISTINCT</code> in constant memory.</p>
              <div class="guide-tags">
                <span class="tag">Materialized Views</span><span class="tag">HyperLogLog</span><span
                  class="tag">-State/-Merge Combinators</span>
              </div>
            </div>

            <div class="guide-callout guide-callout--key">
              <div class="guide-callout-label">üí° Core Idea</div>
              A <strong>Materialized View (MV)</strong> in ClickHouse is like a trigger ‚Äî every INSERT into the source
              table automatically runs a SELECT and inserts the result into a target table. The target table is usually
              an AggregatingMergeTree that stores <em>partial aggregate states</em> rather than final values.
            </div>

            <h3 class="guide-h3">Materialized View + AggregatingMergeTree</h3>
            <div class="guide-code-block">-- Step 1: target table stores partial states (not final numbers)
              CREATE TABLE telemetry_hourly_agg (
              hour DateTime,
              service LowCardinality(String),
              event_count AggregateFunction(count), -- compressed partial HLL state
              unique_users AggregateFunction(uniq, String) -- HyperLogLog sketch
              ) ENGINE = AggregatingMergeTree()
              ORDER BY (service, hour);

              -- Step 2: MV fires on every INSERT into telemetry_events
              CREATE MATERIALIZED VIEW mv_telemetry_hourly
              TO telemetry_hourly_agg AS
              SELECT
              toStartOfHour(timestamp) AS hour,
              service,
              countState() AS event_count, -- ‚Üê -State suffix!
              uniqState(user_id) AS unique_users
              FROM telemetry_events
              GROUP BY hour, service;

              -- Step 3: query uses -Merge suffix to combine partial states
              SELECT hour, service,
              countMerge(event_count) AS events,
              uniqMerge(unique_users) AS distinct_users
              FROM telemetry_hourly_agg
              GROUP BY hour, service
              ORDER BY hour DESC;</div>

            <div class="guide-callout guide-callout--info">
              <div class="guide-callout-label">üìê The -State / -Merge Pattern</div>
              Any aggregate function in ClickHouse has two combinators:
              <ul class="guide-list">
                <li><code>uniqState()</code> ‚Äî stores a HyperLogLog sketch (compact binary blob) instead of the final
                  count</li>
                <li><code>uniqMerge()</code> ‚Äî combines multiple sketches and returns the final estimated count</li>
                <li>This lets you pre-aggregate at insert time and merge at query time</li>
              </ul>
            </div>

            <h3 class="guide-h3">HyperLogLog: Counting Billions in Bytes</h3>
            <p class="guide-p"><code>uniq()</code> uses HyperLogLog to count distinct values in <strong>constant
                memory</strong> (~2KB per group), regardless of cardinality. Great for "unique users" at web scale. Need
              exact? Use <code>uniqExact()</code> ‚Äî but it's 100x more memory.</p>
            <div class="guide-code-block">-- HLL approximation (fast, O(1) memory)
              SELECT service, uniq(user_id) AS approx_users FROM telemetry_events GROUP BY service;

              -- Exact count (slow, O(n) memory)
              SELECT service, uniqExact(user_id) AS exact_users FROM telemetry_events GROUP BY service;

              -- Practical rule: &lt;1% error from HLL is acceptable for analytics
              -- Use uniqExact() only for billing/compliance where exactness matters</div>

            <div class="guide-next-row">
              <button class="btn btn-primary" onclick="goToTab('telemetry')">‚Üí See Telemetry live data</button>
              <button class="btn" onclick="showGuideModule(5, document.getElementById('gbtn-5'))">Next: Logging &amp;
                TTL ‚Üí</button>
            </div>
          </div>

          <!-- ‚îÄ‚îÄ MODULE 5: LOGGING & TTL ‚îÄ‚îÄ -->
          <div class="guide-lesson" id="glesson-5" style="display:none">
            <div class="guide-lesson-hd">
              <div class="guide-lesson-num">Module 05</div>
              <h2 class="guide-lesson-title">Structured Logging &amp; TTL</h2>
              <p class="guide-lesson-desc">ClickHouse is one of the best log stores available ‚Äî auto-expiring hot logs,
                instant aggregations, and sub-second text search.</p>
              <div class="guide-tags">
                <span class="tag">TTL</span><span class="tag">LowCardinality</span><span class="tag">LIKE
                  Search</span><span class="tag">Log Lifecycle</span>
              </div>
            </div>

            <div class="guide-callout guide-callout--key">
              <div class="guide-callout-label">üí° Core Idea</div>
              <strong>TTL (Time-To-Live)</strong> is a built-in ClickHouse feature that automatically deletes (or moves
              to cold storage) old rows based on a time expression. No cron jobs, no manual cleanup ‚Äî it runs as a
              background operation during merges.
            </div>

            <h3 class="guide-h3">TTL Expression</h3>
            <div class="guide-code-block">CREATE TABLE app_logs (
              timestamp DateTime,
              level LowCardinality(String), -- ‚Üê saves 50-90% space vs String
              service LowCardinality(String),
              message String
              )
              ENGINE = MergeTree()
              ORDER BY (service, level, timestamp)
              PARTITION BY toDate(timestamp)
              TTL timestamp + INTERVAL 90 DAY -- ‚Üê delete rows older than 90 days
              DELETE -- (default behaviour)
              SETTINGS merge_with_ttl_timeout = 3600; -- check every hour

              -- You can also MOVE to cheaper storage tiers:
              TTL timestamp + INTERVAL 30 DAY TO DISK 'ssd',
              timestamp + INTERVAL 90 DAY TO DISK 's3';</div>

            <h3 class="guide-h3">LowCardinality ‚Äî Automatic Dictionary Encoding</h3>
            <p class="guide-p">When a String column has fewer than ~10,000 unique values (like log levels or service
              names), wrap it in <code>LowCardinality()</code>. ClickHouse automatically stores it as an integer
              dictionary ‚Äî often <strong>10x less space and 2x faster queries</strong>.</p>
            <div class="guide-code-block">-- Without LowCardinality: stores full string for every row
              level String -- 'ERROR', 'ERROR', 'ERROR'... stored 1M times

              -- With LowCardinality: dictionary encoding
              level LowCardinality(String)
              -- Dictionary: {0: 'DEBUG', 1: 'INFO', 2: 'WARN', 3: 'ERROR'}
              -- Column: [3, 3, 1, 3, 2, 1, ...] ‚Üê just integers!

              -- Works transparently ‚Äî no query changes needed:
              WHERE level = 'ERROR' -- still works exactly the same</div>

            <h3 class="guide-h3">Log Search Patterns</h3>
            <div class="guide-code-block">-- Fast: prefix match on the ORDER BY key
              SELECT * FROM app_logs WHERE service = 'api-gateway' AND level = 'ERROR'
              ORDER BY timestamp DESC LIMIT 100;

              -- LIKE search (full-text, slightly slower ‚Äî scans column values)
              SELECT * FROM app_logs WHERE message LIKE '%timeout%'
              AND timestamp >= now() - INTERVAL 1 HOUR;

              -- Error rate by service (instant due to ORDER BY)
              SELECT service,
              countIf(level = 'ERROR') AS errors,
              count() AS total,
              round(100.0 * countIf(level='ERROR') / count(), 2) AS error_pct
              FROM app_logs WHERE timestamp >= now() - INTERVAL 24 HOUR
              GROUP BY service ORDER BY error_pct DESC;</div>

            <div class="guide-next-row">
              <button class="btn btn-primary" onclick="goToTab('logging')">‚Üí Explore live logs</button>
              <button class="btn" onclick="showGuideModule(6, document.getElementById('gbtn-6'))">Next: Cost &amp;
                Aggregations ‚Üí</button>
            </div>
          </div>

          <!-- ‚îÄ‚îÄ MODULE 6: COST & AGGREGATIONS ‚îÄ‚îÄ -->
          <div class="guide-lesson" id="glesson-6" style="display:none">
            <div class="guide-lesson-hd">
              <div class="guide-lesson-num">Module 06</div>
              <h2 class="guide-lesson-title">Cost Tracking &amp; Aggregations</h2>
              <p class="guide-lesson-desc">Build a self-maintaining cost dashboard: SummingMergeTree auto-aggregates
                spend, while CollapsingMergeTree handles budget corrections without mutations.</p>
              <div class="guide-tags">
                <span class="tag">SummingMergeTree</span><span class="tag">CollapsingMergeTree</span><span
                  class="tag">Budget Alerts</span>
              </div>
            </div>

            <div class="guide-callout guide-callout--key">
              <div class="guide-callout-label">üí° Core Idea</div>
              <strong>SummingMergeTree</strong> is a zero-cost aggregation layer. Every time ClickHouse merges parts, it
              automatically sums your numeric columns for rows with the same ORDER BY key. No ETL job, no cron tab, no
              scheduled aggregation ‚Äî the DB maintains the totals itself.
            </div>

            <h3 class="guide-h3">SummingMergeTree: How Totals Stay Current</h3>
            <div class="guide-code-block">-- cost_usage: appended continuously by services
              ENGINE = SummingMergeTree((cost_usd, api_calls, tokens_used))
              ORDER BY (team, service, toDate(timestamp))

              -- 100 inserts happen during the day:
              INSERT INTO cost_usage VALUES ('2024-01-15', 'api-gateway', 'platform', 0.0012, 12, 800);
              INSERT INTO cost_usage VALUES ('2024-01-15', 'api-gateway', 'platform', 0.0008, 8, 500);
              -- ... 98 more inserts ...

              -- Background merge collapses them automatically:
              -- Result: ('2024-01-15', 'api-gateway', 'platform', SUM(cost), SUM(calls), SUM(tokens))

              -- Always query with sum() for correctness (some parts may not be merged yet):
              SELECT team, service, sum(cost_usd) AS total_cost
              FROM cost_usage GROUP BY team, service ORDER BY total_cost DESC;</div>

            <h3 class="guide-h3">Budget Alerts with CollapsingMergeTree</h3>
            <div class="guide-code-block">-- Check: which teams exceeded their daily budget?
              SELECT cu.service, cu.team,
              sum(cu.cost_usd) AS daily_spend,
              -- CollapsingMergeTree net budget (sign=+1 adds, sign=-1 cancels)
              sum(bl.budget_usd * bl.sign) AS budget,
              round(100.0 * sum(cu.cost_usd) / sum(bl.budget_usd * bl.sign), 1) AS used_pct
              FROM cost_usage cu
              JOIN budget_limits bl ON cu.team = bl.team AND bl.date = toDate(cu.timestamp)
              WHERE cu.timestamp >= today() AND bl.sign = 1
              GROUP BY cu.service, cu.team
              HAVING daily_spend > budget * 0.8 -- alert at 80%
              ORDER BY used_pct DESC;</div>

            <div class="guide-next-row">
              <button class="btn btn-primary" onclick="goToTab('costs')">‚Üí See live cost data</button>
              <button class="btn" onclick="showGuideModule(7, document.getElementById('gbtn-7'))">Next: Cluster &amp;
                Replication ‚Üí</button>
            </div>
          </div>

          <!-- ‚îÄ‚îÄ MODULE 7: CLUSTER & REPLICATION ‚îÄ‚îÄ -->
          <div class="guide-lesson" id="glesson-7" style="display:none">
            <div class="guide-lesson-hd">
              <div class="guide-lesson-num">Module 07</div>
              <h2 class="guide-lesson-title">Cluster &amp; Replication</h2>
              <p class="guide-lesson-desc">Scale out horizontally with sharding, and achieve high availability with
                replication ‚Äî understand the difference and when you need each.</p>
              <div class="guide-tags">
                <span class="tag">Distributed Table</span><span class="tag">Sharding</span><span
                  class="tag">ReplicatedMergeTree</span><span class="tag">ClickHouse Keeper</span>
              </div>
            </div>

            <div class="guide-callout guide-callout--key">
              <div class="guide-callout-label">üí° Two Different Concepts</div>
              <strong>Sharding</strong> = split <em>different</em> data across nodes (for scale).
              <strong>Replication</strong> = copy the <em>same</em> data across nodes (for availability). Production
              clusters usually use both ‚Äî 2 shards √ó 2 replicas = 4 nodes total.
            </div>

            <h3 class="guide-h3">Sharding: The Distributed Table</h3>
            <p class="guide-p">A <code>Distributed</code> table is a <strong>virtual table</strong> ‚Äî it contains no
              data itself. INSERTs fan out to local tables on each shard; SELECTs fan out and merge. The sharding key
              (usually a hash of a user ID) determines which shard each row goes to.</p>
            <div class="guide-code-block">-- Local table on EACH shard node:
              CREATE TABLE events_local ON CLUSTER demo_cluster (...)
              ENGINE = ReplicatedMergeTree('/ch/tables/{shard}/events', '{replica}')
              ORDER BY (user_id, timestamp);

              -- Distributed table: virtual, one per cluster
              CREATE TABLE events_dist ON CLUSTER demo_cluster (...)
              ENGINE = Distributed(
              demo_cluster, -- cluster name from config.xml
              default, -- database
              events_local, -- local table on each shard
              murmurHash3_32(user_id) -- sharding key ‚Üí deterministic routing
              );

              -- Write to distributed ‚Üí auto-routes to correct shard:
              INSERT INTO events_dist VALUES ('user-42', ...);
              -- murmurHash3_32('user-42') % 2 = shard 1 ‚Üí goes to clickhouse-node1

              -- Read from distributed ‚Üí fan-out, parallel scan, merge:
              SELECT count(), service FROM events_dist GROUP BY service;</div>

            <h3 class="guide-h3">Replication: ClickHouse Keeper</h3>
            <p class="guide-p"><code>ReplicatedMergeTree</code> uses ClickHouse Keeper (a ZooKeeper-compatible service)
              to track a shared INSERT log. When node1 inserts data, Keeper records the log entry ‚Äî node2 reads it and
              applies the same insert. This is asynchronous and happens within milliseconds.</p>
            <div class="guide-code-block">-- Same ZK path, different replica macro ‚Üí two replicas of same data
              CREATE TABLE events_replicated (
              timestamp DateTime, service String, user_id String
              ) ENGINE = ReplicatedMergeTree(
              '/clickhouse/tables/ha/events_replicated', -- shared ZK path
              '{replica}' -- expands to 'replica-1' on node1, 'replica-2' on node2
              )
              ORDER BY (service, timestamp);

              -- How Keeper coordinates it:
              -- 1. INSERT arrives at replica-1 (node1)
              -- 2. node1 writes part locally AND logs entry to Keeper
              -- 3. node2 reads Keeper log ‚Üí fetches the part from node1
              -- 4. Both replicas now have identical data

              -- Check replication status:
              SELECT replica_name, is_leader, queue_size, inserts_in_queue
              FROM system.replicas WHERE table = 'events_replicated';</div>

            <div class="guide-callout guide-callout--info">
              <div class="guide-callout-label">üéâ You've completed the ClickHouse guide!</div>
              You now understand the full stack: columnar storage ‚Üí MergeTree parts ‚Üí engine variants ‚Üí materialized
              views ‚Üí TTL ‚Üí sharding + replication. The next step is to explore the live demos in each tab, then try
              writing your own queries in the SQL Playground.
            </div>

            <div class="guide-next-row">
              <button class="btn btn-primary" onclick="goToTab('cluster')">‚Üí See the live cluster demo</button>
              <button class="btn" onclick="goToTab('query')">‚Üí Try the SQL Playground</button>
            </div>
          </div>

        </div><!-- end guide-main -->
      </div><!-- end guide-layout -->
    </section>

    <!-- ‚îÄ‚îÄ‚îÄ 13 MISTAKES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <section class="tab-panel" id="tab-mistakes">
      <div class="page-header">
        <h1>13 Common ClickHouse Mistakes</h1>
        <p class="page-subtitle">
          A curated breakdown of the most common pitfalls new ClickHouse users encounter ‚Äî
          what causes them, what goes wrong, and exactly how to fix them.
          Based on the official <a href="https://clickhouse.com/blog/common-getting-started-issues-with-clickhouse"
            target="_blank" class="guide-link">ClickHouse engineering blog</a>.
        </p>
      </div>

      <!-- Filter bar -->
      <div class="mistakes-filter-bar glass">
        <span class="mistakes-filter-label">Filter by category:</span>
        <button class="mf-btn active" onclick="filterMistakes('all', this)">All 13</button>
        <button class="mf-btn" onclick="filterMistakes('ingestion', this)">üö¢ Ingestion</button>
        <button class="mf-btn" onclick="filterMistakes('schema', this)">üóÇ Schema</button>
        <button class="mf-btn" onclick="filterMistakes('query', this)">üîç Query</button>
        <button class="mf-btn" onclick="filterMistakes('ops', this)">‚öôÔ∏è Ops</button>
        <button class="mf-btn" onclick="filterMistakes('views', this)">üìê Mat. Views</button>
      </div>

      <div class="mistakes-grid" id="mistakesGrid">

        <!-- ‚ë† Too many parts -->
        <div class="mistake-card glass" data-category="ingestion">
          <div class="mistake-card-header">
            <div class="mistake-num">01</div>
            <div class="mistake-meta">
              <div class="mistake-title">Too Many Parts</div>
              <span class="mistake-badge badge-ingestion">üö¢ Ingestion</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-symptom">
              <span class="symptom-icon">üî¥</span>
              <code>DB::Exception: Too many parts (N in total)</code>
            </div>

            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Three common causes: <strong>(1) High-cardinality partition key</strong> ‚Äî using
                  <code>date_time_ms</code> as a partition key creates thousands of folders; parts in different
                  partitions are never merged. <strong>(2) Many tiny inserts</strong> ‚Äî every single INSERT creates a
                  new part. <strong>(3) Too many materialized views</strong> ‚Äî each MV adds part pressure on inserts.
                </p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Queries slow down because more parts = more index files to evaluate. In extreme cases
                  ClickHouse throws <code>Too Many Parts</code> and rejects further inserts. High part counts also cause
                  slower startup and increased Keeper load in replicated setups.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="mistakes-compare">
                  <div class="mc-panel mc-bad">
                    <div class="mc-label">‚ùå Wrong ‚Äî high-cardinality partition</div>
                    <div class="guide-code-block">CREATE TABLE events (
                      ts DateTime,
                      service String
                      ) ENGINE = MergeTree()
                      -- BAD: millions of unique values!
                      PARTITION BY toStartOfMinute(ts)
                      ORDER BY (service, ts);</div>
                  </div>
                  <div class="mc-panel mc-good">
                    <div class="mc-label">‚úÖ Right ‚Äî low-cardinality partition + batched inserts</div>
                    <div class="guide-code-block">CREATE TABLE events (
                      ts DateTime,
                      service String
                      ) ENGINE = MergeTree()
                      -- GOOD: &lt; 1000 unique partition values
                      PARTITION BY toYYYYMM(ts)
                      ORDER BY (service, ts);

                      -- Batch inserts: 10k‚Äì100k rows at a time
                      -- OR use async inserts:
                      INSERT INTO events SETTINGS
                      async_insert = 1,
                      wait_for_async_insert = 1
                      VALUES (...);</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- LIVE DEMO #01 -->
            <div class="live-demo-panel v2">
              <div class="ldp-header">
                <span class="ldp-icon">üî¨</span>
                <span class="ldp-title">Try it live ‚Äî 15 individual INSERTs vs 1 batch INSERT</span>
                <div class="ldp-btn-group">
                  <button class="ldp-btn-wrong" onclick="runWrong('parts', this)">‚ñ∂ Run ‚ùå Wrong</button>
                  <button class="ldp-btn-fixed" onclick="runFixed('parts', this)">‚ñ∂ Run ‚úÖ Fixed</button>
                  <button class="ldp-btn-reset" onclick="runReset('parts', this)">‚Ü∫ Reset</button>
                </div>
              </div>
              <div class="ldp-split" id="split-parts">
                <div class="ldp-wrong-pane" id="wrong-parts">
                  <div class="ldp-pane-hint">Click ‚ñ∂ Run ‚ùå Wrong to see the mistake</div>
                </div>
                <div class="ldp-fixed-pane" id="fixed-parts">
                  <div class="ldp-pane-hint">Click ‚ñ∂ Run ‚úÖ Fixed to see the solution</div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- ‚ë° Going horizontal too early -->
        <div class="mistake-card glass" data-category="ops">
          <div class="mistake-card-header">
            <div class="mistake-num">02</div>
            <div class="mistake-meta">
              <div class="mistake-title">Going Horizontal Too Early</div>
              <span class="mistake-badge badge-ops">‚öôÔ∏è Ops</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">New users immediately deploy dozens of ClickHouse nodes on Kubernetes, expecting
                  horizontal scaling to be the answer ‚Äî just like with stateless services.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Unnecessary operational complexity, higher costs, and potentially <em>worse</em>
                  query performance due to JOIN data being shuffled over the network. ClickHouse is designed to saturate
                  a single large machine (hundreds of cores, TBs of RAM).</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="guide-callout guide-callout--info">
                  <div class="guide-callout-label">üí° Scale Vertically First</div>
                  ClickHouse parallelizes every query stage across all CPU cores by default
                  (<code>max_threads = number of cores</code>). A single node with 64 cores and 512 GB RAM will
                  comfortably handle billions of rows. Only add nodes for <strong>redundancy</strong> (2 replicas) or
                  when a single machine is genuinely exhausted.
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- ‚ë¢ Mutation Pain -->
        <div class="mistake-card glass" data-category="ops">
          <div class="mistake-card-header">
            <div class="mistake-num">03</div>
            <div class="mistake-meta">
              <div class="mistake-title">Mutation Pain</div>
              <span class="mistake-badge badge-ops">‚öôÔ∏è Ops</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Running frequent <code>ALTER TABLE ... UPDATE/DELETE</code> (classic mutations) to
                  modify data ‚Äî treating ClickHouse like an OLTP database where updates are routine.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Classic mutations <strong>rewrite entire data parts</strong>. They compete with
                  background merges for CPU/IO. On replicated clusters, every replica applies the mutation
                  independently. This cascades into the "Too Many Parts" problem, replication delays, and extremely high
                  resource usage.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="mistakes-compare">
                  <div class="mc-panel mc-bad">
                    <div class="mc-label">‚ùå Slow ‚Äî classic mutation rewrites full parts</div>
                    <div class="guide-code-block">-- Rewrites ALL parts containing this service!
                      ALTER TABLE events
                      UPDATE status = 'archived'
                      WHERE service = 'legacy-api';</div>
                  </div>
                  <div class="mc-panel mc-good">
                    <div class="mc-label">‚úÖ Fast ‚Äî lightweight update (patch parts)</div>
                    <div class="guide-code-block">-- Writes only a compact "patch part" for
                      -- the changed column values. Up to 1000x faster!
                      UPDATE events
                      SET status = 'archived'
                      WHERE service = 'legacy-api';

                      -- For deletes, use lightweight DELETE:
                      DELETE FROM events
                      WHERE ts &lt; now() - INTERVAL 90 DAY;</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- ‚ë£ Semi-structured data -->
        <div class="mistake-card glass" data-category="schema">
          <div class="mistake-card-header">
            <div class="mistake-num">04</div>
            <div class="mistake-meta">
              <div class="mistake-title">Mishandling Semi-Structured Data</div>
              <span class="mistake-badge badge-schema">üóÇ Schema</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Storing JSON as a raw <code>String</code> column and parsing it at query time with
                  <code>JSONExtractString()</code>, or blindly using <code>Map(String, String)</code> for everything.
                  Both sacrifice compression and query speed.
                </p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">String columns can't be compressed efficiently by ClickHouse's columnar codec.
                  Parsing JSON at query time is slow and error-prone. Map columns store data as arrays, which is harder
                  to index.s</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="mistakes-compare">
                  <div class="mc-panel mc-bad">
                    <div class="mc-label">‚ùå Slow ‚Äî raw JSON string parsed at query time</div>
                    <div class="guide-code-block">CREATE TABLE logs (
                      ts DateTime,
                      -- ‚ùå no compression, slow extraction
                      raw_json String
                      ) ENGINE = MergeTree()
                      ORDER BY ts;

                      -- Query must parse on every read:
                      SELECT JSONExtractString(raw_json, 'user_id')
                      FROM logs WHERE ts > now() - INTERVAL 1 DAY;</div>
                  </div>
                  <div class="mc-panel mc-good">
                    <div class="mc-label">‚úÖ Best ‚Äî explicit columns (known schema)</div>
                    <div class="guide-code-block">CREATE TABLE logs (
                      ts DateTime,
                      -- ‚úÖ typed, compressed, indexed
                      user_id String,
                      level LowCardinality(String),
                      message String
                      ) ENGINE = MergeTree()
                      ORDER BY (level, ts);

                      -- OR for truly dynamic schemas, use JSON type:
                      CREATE TABLE logs (
                      ts DateTime,
                      payload JSON -- native JSON type
                      ) ENGINE = MergeTree() ORDER BY ts;</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- ‚ë§ Overuse of Nullable -->
        <div class="mistake-card glass" data-category="schema">
          <div class="mistake-card-header">
            <div class="mistake-num">05</div>
            <div class="mistake-meta">
              <div class="mistake-title">Overuse of Nullable</div>
              <span class="mistake-badge badge-schema">üóÇ Schema</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Defaulting to <code>Nullable(String)</code>, <code>Nullable(UInt64)</code>, etc. for
                  any column that might be empty ‚Äî just like in a traditional SQL database.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Every <code>Nullable</code> column creates a hidden secondary <code>UInt8</code>
                  "null mask" column that must be read alongside the data column on every query. This doubles storage
                  I/O for those columns and almost always hurts performance.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="mistakes-compare">
                  <div class="mc-panel mc-bad">
                    <div class="mc-label">‚ùå Nullable everywhere ‚Äî extra hidden null-mask column</div>
                    <div class="guide-code-block">CREATE TABLE users (
                      id UInt64,
                      email Nullable(String), -- ‚ùå extra null column
                      age Nullable(UInt8), -- ‚ùå extra null column
                      country Nullable(String) -- ‚ùå extra null column
                      ) ENGINE = MergeTree()
                      ORDER BY id;</div>
                  </div>
                  <div class="mc-panel mc-good">
                    <div class="mc-label">‚úÖ Use sentinel default values instead</div>
                    <div class="guide-code-block">CREATE TABLE users (
                      id UInt64,
                      email String DEFAULT '', -- ‚úÖ empty string = "null"
                      age UInt8 DEFAULT 0, -- ‚úÖ 0 = "unknown"
                      country LowCardinality(String) DEFAULT ''
                      ) ENGINE = MergeTree()
                      ORDER BY id;

                      -- Query: filter out sentinel values
                      SELECT * FROM users WHERE email != '';</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- LIVE DEMO #05 -->
            <div class="live-demo-panel v2">
              <div class="ldp-header">
                <span class="ldp-icon">üî¨</span>
                <span class="ldp-title">Try it live ‚Äî Nullable(String) vs String DEFAULT '' storage cost</span>
                <div class="ldp-btn-group">
                  <button class="ldp-btn-wrong" onclick="runWrong('nullable', this)">‚ñ∂ Run ‚ùå Wrong</button>
                  <button class="ldp-btn-fixed" onclick="runFixed('nullable', this)">‚ñ∂ Run ‚úÖ Fixed</button>
                  <button class="ldp-btn-reset" onclick="runReset('nullable', this)">‚Ü∫ Reset</button>
                </div>
              </div>
              <div class="ldp-split" id="split-nullable">
                <div class="ldp-wrong-pane" id="wrong-nullable">
                  <div class="ldp-pane-hint">Click ‚ñ∂ Run ‚ùå Wrong to create a Nullable table with 2k rows</div>
                </div>
                <div class="ldp-fixed-pane" id="fixed-nullable">
                  <div class="ldp-pane-hint">Click ‚ñ∂ Run ‚úÖ Fixed to compare with DEFAULT values</div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- ‚ë• Insert-time deduplication surprise -->
        <div class="mistake-card glass" data-category="ingestion">
          <div class="mistake-card-header">
            <div class="mistake-num">06</div>
            <div class="mistake-meta">
              <div class="mistake-title">Insert-Time Deduplication Surprise</div>
              <span class="mistake-badge badge-ingestion">üö¢ Ingestion</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-symptom">
              <span class="symptom-icon">üòÆ</span>
              Inserted 8 rows twice ‚Ä¶ but SELECT only shows 4 rows!
            </div>
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">On replicated tables (including ClickHouse Cloud), ClickHouse hashes each INSERT
                  block. If the exact same block is submitted again (same rows, same order, same size), it is silently
                  ignored. Users are surprised when retried inserts "disappear".</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Not a bug ‚Äî it's intentional idempotency for safe insert retries. But if you expect
                  duplicate rows (e.g., reprocessing events), this will silently drop them. The deduplication window is
                  the last <strong>100 blocks</strong> by default (<code>replicated_deduplication_window = 100</code>).
                </p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="guide-code-block">-- Understand the behavior:
                  -- Block hash is stored in Keeper for last N blocks.
                  -- Identical insert = same hash ‚Üí silently deduplicated.

                  -- To ALLOW duplicate data, change block sizes or
                  -- add a random nonce column so hashes differ:
                  INSERT INTO events SELECT *, rand() as nonce FROM ...;

                  -- To DISABLE deduplication on non-replicated tables:
                  CREATE TABLE events (...) ENGINE = MergeTree()
                  ORDER BY ts
                  SETTINGS non_replicated_deduplication_window = 0;

                  -- Or check: how many blocks are being tracked?
                  SELECT * FROM system.zookeeper
                  WHERE path LIKE '/clickhouse/tables/%/blocks';</div>
              </div>
            </div>

            <!-- LIVE DEMO #06 -->
            <div class="live-demo-panel v2">
              <div class="ldp-header">
                <span class="ldp-icon">üî¨</span>
                <span class="ldp-title">Try it live ‚Äî Retry inserts on non-replicated vs ReplacingMergeTree</span>
                <div class="ldp-btn-group">
                  <button class="ldp-btn-wrong" onclick="runWrong('dedup', this)">‚ñ∂ Run ‚ùå Wrong</button>
                  <button class="ldp-btn-fixed" onclick="runFixed('dedup', this)">‚ñ∂ Run ‚úÖ Fixed</button>
                </div>
              </div>
              <div class="ldp-split" id="split-dedup">
                <div class="ldp-wrong-pane" id="wrong-dedup">
                  <div class="ldp-pane-hint">Click ‚ñ∂ Run ‚ùå Wrong ‚Äî inserts same block twice, counts the result</div>
                </div>
                <div class="ldp-fixed-pane" id="fixed-dedup">
                  <div class="ldp-pane-hint">Click ‚ñ∂ Run ‚úÖ Fixed ‚Äî shows ReplacingMergeTree + SELECT FINAL</div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- ‚ë¶ Poor Primary Key Selection -->
        <div class="mistake-card glass" data-category="schema">
          <div class="mistake-card-header">
            <div class="mistake-num">07</div>
            <div class="mistake-meta">
              <div class="mistake-title">Poor Primary Key Selection</div>
              <span class="mistake-badge badge-schema">üóÇ Schema</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Choosing a primary key based on OLTP instincts ‚Äî putting a high-cardinality UUID
                  first, or picking columns that don't match actual query filters. ClickHouse's sparse index is
                  fundamentally different from a B-tree.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">A poorly ordered primary key means ClickHouse cannot skip granules efficiently ‚Üí full
                  table scans even for simple queries. It also hurts compression because ClickHouse compresses better
                  when data is sorted by low-cardinality columns first.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="mistakes-compare">
                  <div class="mc-panel mc-bad">
                    <div class="mc-label">‚ùå UUID first ‚Äî high cardinality, kills compression</div>
                    <div class="guide-code-block">CREATE TABLE events (
                      id UUID,
                      service LowCardinality(String),
                      ts DateTime,
                      level LowCardinality(String)
                      ) ENGINE = MergeTree()
                      -- ‚ùå High-cardinality UUID first
                      ORDER BY (id, service, ts);</div>
                  </div>
                  <div class="mc-panel mc-good">
                    <div class="mc-label">‚úÖ Low ‚Üí high cardinality order = best compression + skipping</div>
                    <div class="guide-code-block">CREATE TABLE events (
                      id UUID,
                      service LowCardinality(String), -- ~10 values
                      level LowCardinality(String), -- ~5 values
                      ts DateTime, -- millions of values
                      user_id String -- billions of values
                      ) ENGINE = MergeTree()
                      -- ‚úÖ Low cardinality first ‚Üí best compression
                      -- ‚úÖ Match your WHERE clause columns
                      ORDER BY (service, level, ts);

                      -- Rule: put columns you filter on most in ORDER BY.
                      -- Order by ascending cardinality within those.</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- LIVE DEMO #07 -->
            <div class="live-demo-panel v2">
              <div class="ldp-header">
                <span class="ldp-icon">üî¨</span>
                <span class="ldp-title">Try it live ‚Äî EXPLAIN: WHERE user_id vs WHERE service (PK column)</span>
                <div class="ldp-btn-group">
                  <button class="ldp-btn-wrong" onclick="runWrong('pk', this)">‚ñ∂ Run ‚ùå Wrong</button>
                  <button class="ldp-btn-fixed" onclick="runFixed('pk', this)">‚ñ∂ Run ‚úÖ Fixed</button>
                </div>
              </div>
              <div class="ldp-split" id="split-pk">
                <div class="ldp-wrong-pane" id="wrong-pk">
                  <div class="ldp-pane-hint">Filter on user_id ‚Äî not in primary key ‚Üí full scan</div>
                </div>
                <div class="ldp-fixed-pane" id="fixed-pk">
                  <div class="ldp-pane-hint">Filter on service ‚Äî first ORDER BY column ‚Üí index skip</div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- ‚ëß Overuse of skip indices -->
        <div class="mistake-card glass" data-category="query">
          <div class="mistake-card-header">
            <div class="mistake-num">08</div>
            <div class="mistake-meta">
              <div class="mistake-title">Overuse of Data Skipping Indices</div>
              <span class="mistake-badge badge-query">üîç Query</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Adding bloom filter or minmax skip indices to every column that appears in a WHERE
                  clause, hoping it will speed up all queries automatically.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Skip indices only help when there's a strong correlation between the primary key
                  column and the indexed column. Without correlation, the index matches most granules anyway (reads
                  everything) ‚Äî incurring index overhead with zero benefit. They also slow INSERT performance because
                  the index must be updated.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="guide-callout guide-callout--warn">
                  <div class="guide-callout-label">‚ö†Ô∏è Order of operations for query optimization</div>
                  <strong>1st:</strong> Improve PRIMARY KEY / ORDER BY to match query patterns.<br />
                  <strong>2nd:</strong> Add a <em>Materialized View</em> with a different ORDER BY for alternate access
                  patterns.<br />
                  <strong>3rd:</strong> Consider <em>Projections</em> for pre-aggregated data.<br />
                  <strong>Last resort only:</strong> Data skipping indices ‚Äî only when there's high correlation between
                  primary key and indexed column.
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- ‚ë® LIMIT doesn't short-circuit -->
        <div class="mistake-card glass" data-category="query">
          <div class="mistake-card-header">
            <div class="mistake-num">09</div>
            <div class="mistake-meta">
              <div class="mistake-title">LIMIT Doesn't Always Short-Circuit</div>
              <span class="mistake-badge badge-query">üîç Query</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Assuming <code>LIMIT 10</code> always makes queries faster ‚Äî applying OLTP intuition
                  where fewer results = faster execution.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">For aggregations, ClickHouse must scan the <em>entire</em> table before it can apply
                  LIMIT. A query like <code>SELECT a, count() FROM t GROUP BY a ORDER BY b LIMIT 1</code> scans 27
                  million rows even though you only want 1 row back.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="mistakes-compare">
                  <div class="mc-panel mc-bad">
                    <div class="mc-label">‚ùå Full scan ‚Äî 3 sec, 27M rows read</div>
                    <div class="guide-code-block">SELECT postcode1, postcode2,
                      avg(price) AS avg_price
                      FROM uk_price_paid
                      GROUP BY postcode1, postcode2
                      LIMIT 1;
                      -- Elapsed: 3.028 sec, read 27.55M rows</div>
                  </div>
                  <div class="mc-panel mc-good">
                    <div class="mc-label">‚úÖ Early termination ‚Äî 1 sec, 4.8M rows read</div>
                    <div class="guide-code-block">SELECT postcode1, postcode2,
                      avg(price) AS avg_price
                      FROM uk_price_paid
                      GROUP BY postcode1, postcode2
                      LIMIT 1
                      -- Enable in-order aggregation short-circuit:
                      SETTINGS optimize_aggregation_in_order = 1;
                      -- Elapsed: 0.999 sec, read 4.81M rows (83% less!)</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- LIVE DEMO #09 -->
            <div class="live-demo-panel v2">
              <div class="ldp-header">
                <span class="ldp-icon">üî¨</span>
                <span class="ldp-title">Try it live ‚Äî GROUP BY + LIMIT 1: timing with and without early
                  termination</span>
                <div class="ldp-btn-group">
                  <button class="ldp-btn-wrong" onclick="runWrong('limit', this)">‚ñ∂ Run ‚ùå Wrong</button>
                  <button class="ldp-btn-fixed" onclick="runFixed('limit', this)">‚ñ∂ Run ‚úÖ Fixed</button>
                </div>
              </div>
              <div class="ldp-split" id="split-limit">
                <div class="ldp-wrong-pane" id="wrong-limit">
                  <div class="ldp-pane-hint">Default ‚Äî full aggregation before LIMIT</div>
                </div>
                <div class="ldp-fixed-pane" id="fixed-limit">
                  <div class="ldp-pane-hint">optimize_aggregation_in_order=1 ‚Äî early termination</div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- ‚ë© Readonly tables -->
        <div class="mistake-card glass" data-category="ops">
          <div class="mistake-card-header">
            <div class="mistake-num">10</div>
            <div class="mistake-meta">
              <div class="mistake-title">Readonly Tables</div>
              <span class="mistake-badge badge-ops">‚öôÔ∏è Ops</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-symptom">
              <span class="symptom-icon">üî¥</span>
              <code>DB::Exception: Table is in readonly mode</code>
            </div>
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">In self-managed replicated setups, co-locating ClickHouse Keeper (the coordination
                  service) on the same machine as ClickHouse, or under-allocating Keeper memory/CPU.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">When a node loses connection to Keeper (coordination service), it enters
                  <strong>read-only mode</strong> ‚Äî all INSERT/ALTER statements fail. This happens most often when
                  Keeper is resource-starved or unreachable. Non-Cloud deployments must manage this carefully.
                </p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="guide-callout guide-callout--info">
                  <div class="guide-callout-label">üí° Keeper best practices</div>
                  ‚Ä¢ Run <strong>ClickHouse Keeper on dedicated hardware</strong> ‚Äî not mixed with ClickHouse
                  itself.<br />
                  ‚Ä¢ Deploy Keeper in a <strong>3-node quorum</strong> for high availability.<br />
                  ‚Ä¢ Prefer <strong>ClickHouse Keeper over ZooKeeper</strong> ‚Äî it's purpose-built, written in C++ (no
                  JVM heap tuning).<br />
                  ‚Ä¢ ClickHouse Cloud users: this is fully managed ‚Äî not your problem! ‚òÅÔ∏è
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- ‚ë™ Memory limit exceeded -->
        <div class="mistake-card glass" data-category="query">
          <div class="mistake-card-header">
            <div class="mistake-num">11</div>
            <div class="mistake-meta">
              <div class="mistake-title">Memory Limit Exceeded</div>
              <span class="mistake-badge badge-query">üîç Query</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-symptom">
              <span class="symptom-icon">üî¥</span>
              <code>DB::Exception: Memory limit (total) exceeded: would use X, maximum: Y</code>
            </div>
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Running large JOINs that put the right-hand table (build side) in memory, or doing
                  high-cardinality GROUP BY aggregations that build massive in-memory hash maps. Also: leaving rogue
                  queries running without resource limits.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">ClickHouse kills the query to protect the server. In severe cases, multiple
                  concurrent heavy queries can OOM the server itself. Common triggers: <code>GROUP BY</code> on UUID or
                  user_id (billions of unique keys), large JOINs not using the small-table-right rule.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="guide-code-block">-- 1. Put smaller table on the RIGHT side of JOIN:
                  SELECT * FROM large_events e
                  JOIN small_users u ON e.user_id = u.id; -- ‚úÖ small on right

                  -- 2. Enable disk-spill for aggregations:
                  SET max_bytes_before_external_group_by = 10000000000; -- 10GB

                  -- 3. Enable disk-spill for JOINs:
                  SET max_bytes_before_external_sort = 10000000000;

                  -- 4. Kill rogue queries by user:
                  SELECT query_id, user, elapsed, memory_usage
                  FROM system.processes ORDER BY memory_usage DESC;

                  KILL QUERY WHERE user = 'data_team' AND elapsed > 60;

                  -- 5. Set per-user memory quotas in users.xml or via SQL:
                  ALTER USER analyst SETTINGS max_memory_usage = 5000000000;</div>
              </div>
            </div>

            <!-- LIVE DEMO #11 -->
            <div class="live-demo-panel v2">
              <div class="ldp-header">
                <span class="ldp-icon">üî¨</span>
                <span class="ldp-title">Try it live ‚Äî Heavy aggregation: no safety nets vs disk-spill settings</span>
                <div class="ldp-btn-group">
                  <button class="ldp-btn-wrong" onclick="runWrong('memory', this)">‚ñ∂ Run ‚ùå Wrong</button>
                  <button class="ldp-btn-fixed" onclick="runFixed('memory', this)">‚ñ∂ Run ‚úÖ Fixed</button>
                </div>
              </div>
              <div class="ldp-split" id="split-memory">
                <div class="ldp-wrong-pane" id="wrong-memory">
                  <div class="ldp-pane-hint">No memory limits ‚Äî could OOM on large tables</div>
                </div>
                <div class="ldp-fixed-pane" id="fixed-memory">
                  <div class="ldp-pane-hint">max_bytes_before_external_group_by ‚Äî safe disk spill</div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- ‚ë´ Materialized View issues -->
        <div class="mistake-card glass" data-category="views">
          <div class="mistake-card-header">
            <div class="mistake-num">12</div>
            <div class="mistake-meta">
              <div class="mistake-title">Materialized View Pitfalls</div>
              <span class="mistake-badge badge-views">üìê Mat. Views</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistakes (4 common ones)</div>
                <p class="ms-text">
                  <strong>a)</strong> Thinking MVs see the full table ‚Äî they only fire on new INSERT blocks.<br />
                  <strong>b)</strong> Attaching 50+ MVs to a single table ‚Äî each adds insert overhead + part
                  pressure.<br />
                  <strong>c)</strong> Using CPU-heavy state functions (e.g., <code>quantileState</code>) on every
                  insert.<br />
                  <strong>d)</strong> Mismatched schema between the MV SELECT and the target AggregatingMergeTree table.
                </p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Slow inserts, cascading "Too Many Parts" from all the MV target tables, silent data
                  corruption when schemas don't match, or MVs that don't reflect mutations/partition drops on the source
                  table.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="mistakes-compare">
                  <div class="mc-panel mc-bad">
                    <div class="mc-label">‚ùå Schema mismatch ‚Äî column order relied on, not names</div>
                    <div class="guide-code-block">-- Target table:
                      CREATE TABLE summary (
                      day Date, service String, visits AggregateFunction(sum, Int64)
                      ) ENGINE = AggregatingMergeTree() ORDER BY (day, service);

                      -- ‚ùå MV column order doesn't match target column names!
                      CREATE MATERIALIZED VIEW mv_summary TO summary AS
                      SELECT toDate(ts) AS day, service,
                      sumState(1) AS cnt -- "cnt" != "visits"!
                      FROM events GROUP BY day, service;</div>
                  </div>
                  <div class="mc-panel mc-good">
                    <div class="mc-label">‚úÖ Explicit aliases matching target table exactly</div>
                    <div class="guide-code-block">CREATE MATERIALIZED VIEW mv_summary TO summary AS
                      SELECT
                      toDate(ts) AS day,
                      service,
                      -- ‚úÖ alias matches target column name exactly
                      sumState(1) AS visits
                      FROM events GROUP BY day, service;

                      -- ‚úÖ Enable parallel view processing to reduce latency:
                      SET parallel_view_processing = 1;</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- LIVE DEMO #12 -->
            <div class="live-demo-panel v2">
              <div class="ldp-header">
                <span class="ldp-icon">üî¨</span>
                <span class="ldp-title">Try it live ‚Äî MV created after data (0 rows) vs backfill via INSERT INTO
                  SELECT</span>
                <div class="ldp-btn-group">
                  <button class="ldp-btn-wrong" onclick="runWrong('mv', this)">‚ñ∂ Run ‚ùå Wrong</button>
                  <button class="ldp-btn-fixed" onclick="runFixed('mv', this)">‚ñ∂ Run ‚úÖ Fixed</button>
                  <button class="ldp-btn-reset" onclick="runReset('mv', this)">‚Ü∫ Reset</button>
                </div>
              </div>
              <div class="ldp-split" id="split-mv">
                <div class="ldp-wrong-pane" id="wrong-mv">
                  <div class="ldp-pane-hint">Create MV after existing data ‚Äî see how many rows it captured</div>
                </div>
                <div class="ldp-fixed-pane" id="fixed-mv">
                  <div class="ldp-pane-hint">Run the backfill INSERT INTO ... SELECT to populate historical data</div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- ‚ë¨ Experimental features in production -->
        <div class="mistake-card glass" data-category="ops">
          <div class="mistake-card-header">
            <div class="mistake-num">13</div>
            <div class="mistake-meta">
              <div class="mistake-title">Experimental Features in Production</div>
              <span class="mistake-badge badge-ops">‚öôÔ∏è Ops</span>
            </div>
            <button class="mistake-toggle" onclick="toggleMistake(this)">‚ñº</button>
          </div>
          <div class="mistake-body">
            <div class="mistake-sections">
              <div class="mistake-section">
                <div class="ms-label ms-what">‚ùå The Mistake</div>
                <p class="ms-text">Building core production functionality on top of features marked
                  <code>experimental</code> (not even <code>beta</code>) ‚Äî such as
                  <code>SET allow_experimental_variant_type = 1</code> or early JSON type builds.
                </p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-consequence">‚ö†Ô∏è What Goes Wrong</div>
                <p class="ms-text">Experimental features can <strong>change APIs without notice, be deprecated, or be
                    removed entirely</strong> in a future release. On-disk formats may not be forward-compatible,
                  meaning a ClickHouse upgrade could corrupt or make your tables unreadable. They are officially
                  unsupported by the ClickHouse team.</p>
              </div>
              <div class="mistake-section">
                <div class="ms-label ms-fix">‚úÖ The Fix</div>
                <div class="guide-callout guide-callout--warn">
                  <div class="guide-callout-label">‚ö†Ô∏è Feature Maturity Levels</div>
                  <strong>üü¢ Production-ready:</strong> No special setting required. Fully supported, stable API.<br />
                  <strong>üü° Beta:</strong> <code>SET allow_beta_...</code> ‚Äî On a path to production, officially
                  supported but may have edge cases.<br />
                  <strong>üî¥ Experimental:</strong> <code>SET allow_experimental_...</code> ‚Äî Community prototypes. APIs
                  can change. <strong>Do NOT build production systems on these.</strong><br /><br />
                  Always check the <a href="https://clickhouse.com/docs/beta-and-experimental-features" target="_blank"
                    class="guide-link">ClickHouse docs feature maturity page</a> before adopting new features.
                </div>
              </div>
            </div>
          </div>
        </div>

      </div><!-- end mistakes-grid -->

      <!-- Summary cheatsheet -->
      <div class="mistakes-cheatsheet glass">
        <div class="section-title" style="margin-top:0">üìã Quick Reference Cheatsheet</div>
        <div class="cheat-grid">
          <div class="cheat-item"><span class="cheat-num">01</span><span>Batch inserts (10k‚Äì100k rows), low-cardinality
              partition key</span></div>
          <div class="cheat-item"><span class="cheat-num">02</span><span>Scale vertically first ‚Äî one big machine &gt;
              many small ones</span></div>
          <div class="cheat-item"><span class="cheat-num">03</span><span>Use lightweight UPDATE/DELETE, not ALTER TABLE
              mutations</span></div>
          <div class="cheat-item"><span class="cheat-num">04</span><span>Explicit typed columns &gt; raw JSON
              strings</span></div>
          <div class="cheat-item"><span class="cheat-num">05</span><span>Avoid Nullable ‚Äî use sentinel default values
              instead</span></div>
          <div class="cheat-item"><span class="cheat-num">06</span><span>Identical insert blocks are deduplicated ‚Äî
              understand replicated_deduplication_window</span></div>
          <div class="cheat-item"><span class="cheat-num">07</span><span>ORDER BY low‚Üíhigh cardinality, matching your
              WHERE clauses</span></div>
          <div class="cheat-item"><span class="cheat-num">08</span><span>Fix primary key before reaching for skip
              indices</span></div>
          <div class="cheat-item"><span class="cheat-num">09</span><span>LIMIT doesn't save aggregations ‚Äî use
              optimize_aggregation_in_order</span></div>
          <div class="cheat-item"><span class="cheat-num">10</span><span>Run ClickHouse Keeper on dedicated hardware,
              3-node quorum</span></div>
          <div class="cheat-item"><span class="cheat-num">11</span><span>Small table on right of JOIN; enable external
              spill for big aggregations</span></div>
          <div class="cheat-item"><span class="cheat-num">12</span><span>Alias MV columns to match target table; cap MVs
              per table &lt; 50</span></div>
          <div class="cheat-item"><span class="cheat-num">13</span><span>Never build production features on experimental
              settings</span></div>
        </div>
      </div>

    </section><!-- end tab-mistakes -->

  </main>

  <script src="app.js"></script>
</body>

</html>